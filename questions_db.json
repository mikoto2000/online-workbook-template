{
  "title": "データベーススペシャリスト試験 問題集（全6分野・120問）",
  "sections": [
    {
      "id": "database-design",
      "title": "データベース設計",
      "questions": [
        {
          "id": "q1-1",
          "type": "single_choice",
          "question": "概念設計で実体(エンティティ)を識別する際、最も優先して確認すべき情報源はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "業務要件を記述したドキュメントやヒアリング結果"
            },
            {
              "value": "b",
              "text": "使用予定のRDBMSの制約一覧"
            },
            {
              "value": "c",
              "text": "サーバのCPUコア数"
            },
            {
              "value": "d",
              "text": "データベースのバックアップポリシー"
            }
          ],
          "correct": "a",
          "explanation": "エンティティは業務で扱う概念を表すため、業務要件やヒアリング内容から抽出するのが基本である。"
        },
        {
          "id": "q1-2",
          "type": "single_choice",
          "question": "論理設計において第3正規形(3NF)まで正規化する主目的として最も適切なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "更新時の不整合を防ぎデータの整合性を高める"
            },
            {
              "value": "b",
              "text": "バックアップサイズを縮小する"
            },
            {
              "value": "c",
              "text": "SQL文の可読性を向上させる"
            },
            {
              "value": "d",
              "text": "同時実行性を高めるためロック範囲を縮小する"
            }
          ],
          "correct": "a",
          "explanation": "正規化は冗長データと更新異常を排除し、整合性を高めることが主目的である。"
        },
        {
          "id": "q1-3",
          "type": "single_choice",
          "question": "弱エンティティ型(weak entity)の識別子に関する説明として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "親エンティティの主キーに自身の識別子を加えた複合キーで識別される"
            },
            {
              "value": "b",
              "text": "単一の自然キーで常に識別される"
            },
            {
              "value": "c",
              "text": "主キーを持たず行番号で識別される"
            },
            {
              "value": "d",
              "text": "代理キーのみで識別される"
            }
          ],
          "correct": "a",
          "explanation": "弱エンティティは親の存在に依存し、親の主キーと自エンティティの部分キーを組み合わせて一意に識別される。"
        },
        {
          "id": "q1-4",
          "type": "single_choice",
          "question": "クロウズフット記法のE-R図で、多側(多重度0..*)を表すシンボルはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "三又(カラスの足)"
            },
            {
              "value": "b",
              "text": "菱形"
            },
            {
              "value": "c",
              "text": "二重線"
            },
            {
              "value": "d",
              "text": "矢印"
            }
          ],
          "correct": "a",
          "explanation": "クロウズフット記法では多側を三又の足(クロウズフット)で表す。"
        },
        {
          "id": "q1-5",
          "type": "single_choice",
          "question": "サロゲートキー(代理キー)を導入する主な利点として最も適切なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "主キーの変更が業務要件に影響を与えにくくなる"
            },
            {
              "value": "b",
              "text": "ストレージ使用量が必ず削減できる"
            },
            {
              "value": "c",
              "text": "参照整合性制約を設定できなくなる"
            },
            {
              "value": "d",
              "text": "アプリケーションでの重複チェックが不要になる"
            }
          ],
          "correct": "a",
          "explanation": "サロゲートキーは意味を持たない固定キーのため、業務キー変動時の影響を最小化できる。"
        },
        {
          "id": "q1-6",
          "type": "single_choice",
          "question": "ビュー(View)を論理設計に組み込む最も大きなメリットはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "物理テーブル構造を変更してもアプリケーションへの影響を最小化できる"
            },
            {
              "value": "b",
              "text": "トランザクションログの生成を抑制できる"
            },
            {
              "value": "c",
              "text": "ストアドプロシージャを不要にできる"
            },
            {
              "value": "d",
              "text": "サーバのCPU負荷を直接低減できる"
            }
          ],
          "correct": "a",
          "explanation": "ビューは論理的レイヤを提供し、下位の物理テーブル変更をアプリケーションから隠蔽する役割を持つ。"
        },
        {
          "id": "q1-7",
          "type": "single_choice",
          "question": "データドメインを厳密に定義して再利用することによる効果として適切なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "属性の型と制約を一元管理し整合性を高められる"
            },
            {
              "value": "b",
              "text": "全ての外部キー制約を自動生成できる"
            },
            {
              "value": "c",
              "text": "SQLインジェクションを完全に防止できる"
            },
            {
              "value": "d",
              "text": "バックアップ運用を簡素化できる"
            }
          ],
          "correct": "a",
          "explanation": "共通ドメインを定義して再利用することで各テーブルで同じ制約を統一的に適用し、データ品質を高められる。"
        },
        {
          "id": "q1-8",
          "type": "single_choice",
          "question": "多対多リレーションを中間テーブルで実装する際の注意点として最も重要なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "中間テーブルに複合主キーまたは一意制約を設定し重複行を排除する"
            },
            {
              "value": "b",
              "text": "中間テーブルには一切のインデックスを設定しない"
            },
            {
              "value": "c",
              "text": "中間テーブルに外部キーを設定しない"
            },
            {
              "value": "d",
              "text": "中間テーブルにトリガを必ず設定する"
            }
          ],
          "correct": "a",
          "explanation": "同一ペアの重複行を防ぐため、中間テーブルには親2列の複合主キー(または一意制約)を設定するのが基本。"
        },
        {
          "id": "q1-9",
          "type": "single_choice",
          "question": "圧縮テーブルを採用した場合に一般的に発生しやすいデメリットはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "CPU使用率が上昇する"
            },
            {
              "value": "b",
              "text": "物理I/Oが増加する"
            },
            {
              "value": "c",
              "text": "参照整合性が維持できなくなる"
            },
            {
              "value": "d",
              "text": "インデックスが使用不能になる"
            }
          ],
          "correct": "a",
          "explanation": "データ伸長・圧縮処理にCPUを使用するため、圧縮率とCPU負荷のトレードオフが生じる。"
        },
        {
          "id": "q1-10",
          "type": "single_choice",
          "question": "クラスタ化インデックス(Clustered Index)を設定したテーブルに対するINSERT大量実行時に発生しやすい現象はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "ページスプリットが頻発しフラグメンテーションが進行する"
            },
            {
              "value": "b",
              "text": "トランザクションログが記録されなくなる"
            },
            {
              "value": "c",
              "text": "テーブルサイズが自動的に縮小する"
            },
            {
              "value": "d",
              "text": "ハッシュ衝突が多発しSELECTが遅くなる"
            }
          ],
          "correct": "a",
          "explanation": "物理順序保持のため途中への挿入でページスプリットが起こり、断片化が蓄積して性能低下を招く。"
        },
        {
          "id": "q1-11",
          "type": "single_choice",
          "question": "マスタデータ管理(MDM)におけるゴールデンレコードを作成する主目的はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "散在するマスタ情報を統合し単一の信頼ソースを提供する"
            },
            {
              "value": "b",
              "text": "バックアッププロセスを廃止する"
            },
            {
              "value": "c",
              "text": "外部キー制約を簡素化する"
            },
            {
              "value": "d",
              "text": "ログテーブル容量を削減する"
            }
          ],
          "correct": "a",
          "explanation": "ゴールデンレコードは複数システムに分散するマスタを統合し、全社で一貫した参照元を提供することを目的とする。"
        },
        {
          "id": "q1-12",
          "type": "single_choice",
          "question": "エンティティライフサイクル図(Entity Life Cycle Diagram)が設計レビューで役立つ理由として最も適切なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "状態遷移とCRUD操作の整合性を可視化できる"
            },
            {
              "value": "b",
              "text": "SQLチューニングの自動化ができる"
            },
            {
              "value": "c",
              "text": "ETL処理を不要にできる"
            },
            {
              "value": "d",
              "text": "ネットワーク帯域を削減できる"
            }
          ],
          "correct": "a",
          "explanation": "ライフサイクル図は状態遷移ごとに許可されるCRUDを示し、不整合や漏れを検出しやすくするため。"
        },
        {
          "id": "q1-13",
          "type": "multiple_choice",
          "question": "外部キー制約を設定することによって得られる効果として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "参照整合性違反データの登録を防止できる"
            },
            {
              "value": "b",
              "text": "結合クエリの実行計画精度向上に寄与する"
            },
            {
              "value": "c",
              "text": "自動的にビューが生成される"
            },
            {
              "value": "d",
              "text": "ON DELETEオプションによりカスケード削除を自動化できる"
            },
            {
              "value": "e",
              "text": "CHECK制約を不要にできる"
            }
          ],
          "correct": [
            "a",
            "b",
            "d"
          ],
          "explanation": "外部キーは整合性を強制し、統計情報を通じてプラン最適化に寄与し、カスケード設定も可能である。"
        },
        {
          "id": "q1-14",
          "type": "multiple_choice",
          "question": "名詞抽出法でエンティティ候補を決定した後に行う検証として適切なものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "CRUD行列表で業務機能とデータ操作の対応を確認する"
            },
            {
              "value": "b",
              "text": "ユースケースごとのステートチャートを作成し整合性を確認する"
            },
            {
              "value": "c",
              "text": "抽出した名詞が属性かエンティティか分類する"
            },
            {
              "value": "d",
              "text": "SQL実行計画を取得してアクセス経路を評価する"
            },
            {
              "value": "e",
              "text": "表記ゆれや同義語を統一する"
            }
          ],
          "correct": [
            "a",
            "c",
            "e"
          ],
          "explanation": "名詞抽出後はCRUD行列表で機能対応確認、属性/エンティティ分類、表記統一を行うのが一般的手順である。"
        },
        {
          "id": "q1-15",
          "type": "multiple_choice",
          "question": "パーティションプルーニングが有効になるSQLの条件として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "WHERE句でパーティションキーを定数比較している"
            },
            {
              "value": "b",
              "text": "パーティションキーに対し関数を適用している"
            },
            {
              "value": "c",
              "text": "パーティションキー同士で等価結合している"
            },
            {
              "value": "d",
              "text": "ORDER BYのみでパーティションキーを参照している"
            },
            {
              "value": "e",
              "text": "パーティション統計情報が最新である"
            }
          ],
          "correct": [
            "a",
            "c",
            "e"
          ],
          "explanation": "定数比較や等価結合はプルーニング対象になり、統計情報が新しいことも前提。関数適用やORDER BYのみではプルーニングが働きにくい。"
        },
        {
          "id": "q1-16",
          "type": "multiple_choice",
          "question": "外部キー制約にON DELETE SET NULLを設定することで実現できる設計上の利点として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "親行削除時に子行を残したまま参照整合性を維持できる"
            },
            {
              "value": "b",
              "text": "子テーブルの物理削除に伴う監査ログを削減できる"
            },
            {
              "value": "c",
              "text": "アプリケーションコードでのNULL設定処理を省略できる"
            },
            {
              "value": "d",
              "text": "子テーブルの検索性能を必ず向上させる"
            },
            {
              "value": "e",
              "text": "トリガが不要になる場合がある"
            }
          ],
          "correct": [
            "a",
            "c",
            "e"
          ],
          "explanation": "SET NULLは参照切替えをDB側で自動処理でき、コード削減やトリガ不要化に寄与するが性能向上は保証しない。"
        },
        {
          "id": "q1-17",
          "type": "multiple_choice",
          "question": "ドメイン(データ型＋制約)を共通定義として活用することによる組織的メリットとして正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "スキーマ間で型の一貫性が保たれる"
            },
            {
              "value": "b",
              "text": "新規開発時の設計工数を削減できる"
            },
            {
              "value": "c",
              "text": "将来の制約変更をドメイン定義だけで反映できる"
            },
            {
              "value": "d",
              "text": "データの暗号化を自動化できる"
            },
            {
              "value": "e",
              "text": "インデックス再構築が不要になる"
            }
          ],
          "correct": [
            "a",
            "b",
            "c"
          ],
          "explanation": "共通ドメインは型・制約の再利用を促し、変更点も一箇所で済むため設計・保守効率が高まる。"
        },
        {
          "id": "q1-18",
          "type": "multiple_choice",
          "question": "逆正規化パターン『列複写』を適用する際の注意点として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "更新時に複写列の整合性を保つためトリガやアプリ側処理が必要"
            },
            {
              "value": "b",
              "text": "参照クエリのJOIN回数を削減し読み取り性能を向上できる"
            },
            {
              "value": "c",
              "text": "ストレージ使用量が増加する可能性がある"
            },
            {
              "value": "d",
              "text": "必ず書き込み性能が向上する"
            },
            {
              "value": "e",
              "text": "列複写を行うと外部キー制約は設定できない"
            }
          ],
          "correct": [
            "a",
            "b",
            "c"
          ],
          "explanation": "列複写はリード性能向上と引き換えに冗長化・整合性維持コスト増大、ストレージ増加のリスクがある。"
        },
        {
          "id": "q1-19",
          "type": "essay",
          "question": "大規模テーブルでレンジパーティショニングとグローバル索引を併用する場合の利点と注意点を300字以内で説明せよ。",
          "correct": "",
          "explanation": "レンジパーティションは時間系列データ運用が容易、グローバル索引は全体検索を高速化。しかしパーティション再編時の索引再構築やロック時間増加に注意。"
        },
        {
          "id": "q1-20",
          "type": "essay",
          "question": "E-R図レビュー時に頻出する設計不備を三つ挙げ、それぞれが運用フェーズで引き起こす問題を具体的に述べよ(300字以内)。",
          "correct": "",
          "explanation": "例: 多対多未解消→冗長データ・性能低下、弱エンティティのキー不足→更新異常、曖昧な多重度→アプリケーション例外や重複データ発生。"
        }
      ]
    },
    {
      "id": "sql",
      "title": "SQL",
      "questions": [
        {
          "id": "q2-1",
          "type": "single_choice",
          "question": "次のSQL文のうち、NULL値を含む列に対して正しく件数をカウントするものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT COUNT(*) FROM orders WHERE discount IS NULL;"
            },
            {
              "value": "b",
              "text": "SELECT COUNT(discount) FROM orders WHERE discount IS NULL;"
            },
            {
              "value": "c",
              "text": "SELECT COUNT(*) FROM orders WHERE discount = NULL;"
            },
            {
              "value": "d",
              "text": "SELECT COUNT(*) FROM orders WHERE discount <> NULL;"
            }
          ],
          "correct": "a",
          "explanation": "NULLの比較にはIS NULLを用いる。'discount = NULL'や'<> NULL'は誤り。COUNT(列名)はNULLを除くため、COUNT(*)で件数を得る必要がある。"
        },
        {
          "id": "q2-2",
          "type": "single_choice",
          "question": "次のSQL文のうち、売上テーブル（sales）から2023年の月別売上合計を求めるクエリとして正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT SUM(amount), MONTH(sale_date) FROM sales GROUP BY sale_date;"
            },
            {
              "value": "b",
              "text": "SELECT MONTH(sale_date), SUM(amount) FROM sales WHERE sale_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY MONTH(sale_date);"
            },
            {
              "value": "c",
              "text": "SELECT SUM(amount) FROM sales GROUP BY MONTH(sale_date);"
            },
            {
              "value": "d",
              "text": "SELECT MONTH(sale_date), amount FROM sales GROUP BY amount;"
            }
          ],
          "correct": "b",
          "explanation": "WHERE句で2023年の範囲を限定し、MONTHで月単位に集計、GROUP BYで月ごとに集計する構文が適切。"
        },
        {
          "id": "q2-3",
          "type": "single_choice",
          "question": "次のSQL文のうち、全ての部署の平均給与より高い給与の従業員を取得するサブクエリの書き方として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT * FROM employees WHERE salary > (SELECT AVG(salary) FROM employees GROUP BY department_id);"
            },
            {
              "value": "b",
              "text": "SELECT * FROM employees WHERE salary > ALL (SELECT AVG(salary) FROM employees GROUP BY department_id);"
            },
            {
              "value": "c",
              "text": "SELECT * FROM employees WHERE salary > ANY (SELECT AVG(salary) FROM employees GROUP BY department_id);"
            },
            {
              "value": "d",
              "text": "SELECT * FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);"
            }
          ],
          "correct": "b",
          "explanation": "ALL句を使えば、全てのグループ（ここでは部署）の平均給与より高い従業員を取得できる。"
        },
        {
          "id": "q2-4",
          "type": "multiple_choice",
          "question": "SQLにおいてビュー（VIEW）を利用するメリットとして適切なものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "複雑なクエリを簡略化できる"
            },
            {
              "value": "b",
              "text": "データベースのバックアップ速度が向上する"
            },
            {
              "value": "c",
              "text": "データのアクセス制限を行いやすくなる"
            },
            {
              "value": "d",
              "text": "更新系トリガーを無効にできる"
            },
            {
              "value": "e",
              "text": "スキーマの抽象化が可能になる"
            }
          ],
          "correct": [
            "a",
            "c",
            "e"
          ],
          "explanation": "ビューは抽象化・再利用・アクセス制御に有効であるが、バックアップやトリガーには直接関与しない。"
        },
        {
          "id": "q2-5",
          "type": "essay",
          "question": "WITH句（共通テーブル式: CTE）の利点と注意点について、業務アプリケーションでの利用例を挙げながら300字以内で説明せよ。",
          "correct": "",
          "explanation": "CTEは可読性向上や再帰クエリに有効だが、パフォーマンスや最適化の影響には注意が必要。"
        },
        {
          "id": "q2-7",
          "type": "single_choice",
          "question": "次のSQL文のうち、サブクエリを相関サブクエリとして使用しているものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT * FROM employees WHERE department_id IN (SELECT department_id FROM departments);"
            },
            {
              "value": "b",
              "text": "SELECT * FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);"
            },
            {
              "value": "c",
              "text": "SELECT e1.* FROM employees e1 WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.department_id = e1.department_id);"
            },
            {
              "value": "d",
              "text": "SELECT * FROM employees WHERE EXISTS (SELECT * FROM departments);"
            }
          ],
          "correct": "c",
          "explanation": "選択肢cは外部クエリの値（e1.department_id）をサブクエリ内で使用しており、相関サブクエリの例である。"
        },
        {
          "id": "q2-7",
          "type": "single_choice",
          "question": "SQLのROLLUP句を使用する目的として最も適切なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "NULL値を削除する"
            },
            {
              "value": "b",
              "text": "階層的な集計を行う"
            },
            {
              "value": "c",
              "text": "トランザクションのロールバックを行う"
            },
            {
              "value": "d",
              "text": "ビューの更新を可能にする"
            }
          ],
          "correct": "b",
          "explanation": "ROLLUPは集計関数と併用し、指定された列の階層に従って小計や合計を生成する。"
        },
        {
          "id": "q2-8",
          "type": "multiple_choice",
          "question": "次のうち、SQLのインデックスに関して正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "インデックスは検索性能の向上に寄与する"
            },
            {
              "value": "b",
              "text": "INSERT時の処理性能を向上させる"
            },
            {
              "value": "c",
              "text": "UNIQUE制約の実現に利用される"
            },
            {
              "value": "d",
              "text": "全文検索には適さない"
            },
            {
              "value": "e",
              "text": "インデックスは自動で削除されることがある"
            }
          ],
          "correct": [
            "a",
            "c"
          ],
          "explanation": "インデックスは検索性能の向上や一意性の保証に役立つが、INSERTやUPDATEでは追加コストがかかる。全文検索用には専用のインデックスが必要。"
        },
        {
          "id": "q2-9",
          "type": "essay",
          "question": "JSON型データをSQLで扱う際の利点と懸念点を、利用例とともに300字以内で説明せよ。",
          "correct": "",
          "explanation": "柔軟なスキーマ表現が可能になるが、インデックスや正規化、バリデーションの問題に注意が必要である。"
        },
        {
          "id": "q2-11",
          "type": "single_choice",
          "question": "次のSQL文のうち、ウィンドウ関数を使用して累積合計を求めているものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT SUM(amount) FROM sales GROUP BY month;"
            },
            {
              "value": "b",
              "text": "SELECT amount, SUM(amount) OVER (ORDER BY sale_date) FROM sales;"
            },
            {
              "value": "c",
              "text": "SELECT amount FROM sales WHERE amount > (SELECT AVG(amount) FROM sales);"
            },
            {
              "value": "d",
              "text": "SELECT * FROM sales WHERE EXISTS (SELECT * FROM refunds WHERE sales.id = refunds.sale_id);"
            }
          ],
          "correct": "b",
          "explanation": "ウィンドウ関数（OVER句）により累積合計を求めることができる。"
        },
        {
          "id": "q2-12",
          "type": "single_choice",
          "question": "次のSQL文のうち、ウィンドウ関数を使用して累積合計を求めているものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT SUM(amount) FROM sales GROUP BY month;"
            },
            {
              "value": "b",
              "text": "SELECT amount, SUM(amount) OVER (ORDER BY sale_date) FROM sales;"
            },
            {
              "value": "c",
              "text": "SELECT amount FROM sales WHERE amount > (SELECT AVG(amount) FROM sales);"
            },
            {
              "value": "d",
              "text": "SELECT * FROM sales WHERE EXISTS (SELECT * FROM refunds WHERE sales.id = refunds.sale_id);"
            }
          ],
          "correct": "b",
          "explanation": "ウィンドウ関数（OVER句）により累積合計を求めることができる。"
        },
        {
          "id": "q2-13",
          "type": "single_choice",
          "question": "次のSQL文のうち、ウィンドウ関数を使用して累積合計を求めているものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT SUM(amount) FROM sales GROUP BY month;"
            },
            {
              "value": "b",
              "text": "SELECT amount, SUM(amount) OVER (ORDER BY sale_date) FROM sales;"
            },
            {
              "value": "c",
              "text": "SELECT amount FROM sales WHERE amount > (SELECT AVG(amount) FROM sales);"
            },
            {
              "value": "d",
              "text": "SELECT * FROM sales WHERE EXISTS (SELECT * FROM refunds WHERE sales.id = refunds.sale_id);"
            }
          ],
          "correct": "b",
          "explanation": "ウィンドウ関数（OVER句）により累積合計を求めることができる。"
        },
        {
          "id": "q2-14",
          "type": "single_choice",
          "question": "次のSQL文のうち、ウィンドウ関数を使用して累積合計を求めているものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT SUM(amount) FROM sales GROUP BY month;"
            },
            {
              "value": "b",
              "text": "SELECT amount, SUM(amount) OVER (ORDER BY sale_date) FROM sales;"
            },
            {
              "value": "c",
              "text": "SELECT amount FROM sales WHERE amount > (SELECT AVG(amount) FROM sales);"
            },
            {
              "value": "d",
              "text": "SELECT * FROM sales WHERE EXISTS (SELECT * FROM refunds WHERE sales.id = refunds.sale_id);"
            }
          ],
          "correct": "b",
          "explanation": "ウィンドウ関数（OVER句）により累積合計を求めることができる。"
        },
        {
          "id": "q2-15",
          "type": "single_choice",
          "question": "次のSQL文のうち、ウィンドウ関数を使用して累積合計を求めているものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT SUM(amount) FROM sales GROUP BY month;"
            },
            {
              "value": "b",
              "text": "SELECT amount, SUM(amount) OVER (ORDER BY sale_date) FROM sales;"
            },
            {
              "value": "c",
              "text": "SELECT amount FROM sales WHERE amount > (SELECT AVG(amount) FROM sales);"
            },
            {
              "value": "d",
              "text": "SELECT * FROM sales WHERE EXISTS (SELECT * FROM refunds WHERE sales.id = refunds.sale_id);"
            }
          ],
          "correct": "b",
          "explanation": "ウィンドウ関数（OVER句）により累積合計を求めることができる。"
        },
        {
          "id": "q2-16",
          "type": "single_choice",
          "question": "次のSQL文のうち、ウィンドウ関数を使用して累積合計を求めているものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT SUM(amount) FROM sales GROUP BY month;"
            },
            {
              "value": "b",
              "text": "SELECT amount, SUM(amount) OVER (ORDER BY sale_date) FROM sales;"
            },
            {
              "value": "c",
              "text": "SELECT amount FROM sales WHERE amount > (SELECT AVG(amount) FROM sales);"
            },
            {
              "value": "d",
              "text": "SELECT * FROM sales WHERE EXISTS (SELECT * FROM refunds WHERE sales.id = refunds.sale_id);"
            }
          ],
          "correct": "b",
          "explanation": "ウィンドウ関数（OVER句）により累積合計を求めることができる。"
        },
        {
          "id": "q2-17",
          "type": "single_choice",
          "question": "次のSQL文のうち、ウィンドウ関数を使用して累積合計を求めているものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT SUM(amount) FROM sales GROUP BY month;"
            },
            {
              "value": "b",
              "text": "SELECT amount, SUM(amount) OVER (ORDER BY sale_date) FROM sales;"
            },
            {
              "value": "c",
              "text": "SELECT amount FROM sales WHERE amount > (SELECT AVG(amount) FROM sales);"
            },
            {
              "value": "d",
              "text": "SELECT * FROM sales WHERE EXISTS (SELECT * FROM refunds WHERE sales.id = refunds.sale_id);"
            }
          ],
          "correct": "b",
          "explanation": "ウィンドウ関数（OVER句）により累積合計を求めることができる。"
        },
        {
          "id": "q2-18",
          "type": "single_choice",
          "question": "次のSQL文のうち、ウィンドウ関数を使用して累積合計を求めているものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT SUM(amount) FROM sales GROUP BY month;"
            },
            {
              "value": "b",
              "text": "SELECT amount, SUM(amount) OVER (ORDER BY sale_date) FROM sales;"
            },
            {
              "value": "c",
              "text": "SELECT amount FROM sales WHERE amount > (SELECT AVG(amount) FROM sales);"
            },
            {
              "value": "d",
              "text": "SELECT * FROM sales WHERE EXISTS (SELECT * FROM refunds WHERE sales.id = refunds.sale_id);"
            }
          ],
          "correct": "b",
          "explanation": "ウィンドウ関数（OVER句）により累積合計を求めることができる。"
        },
        {
          "id": "q2-19",
          "type": "single_choice",
          "question": "次のSQL文のうち、ウィンドウ関数を使用して累積合計を求めているものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT SUM(amount) FROM sales GROUP BY month;"
            },
            {
              "value": "b",
              "text": "SELECT amount, SUM(amount) OVER (ORDER BY sale_date) FROM sales;"
            },
            {
              "value": "c",
              "text": "SELECT amount FROM sales WHERE amount > (SELECT AVG(amount) FROM sales);"
            },
            {
              "value": "d",
              "text": "SELECT * FROM sales WHERE EXISTS (SELECT * FROM refunds WHERE sales.id = refunds.sale_id);"
            }
          ],
          "correct": "b",
          "explanation": "ウィンドウ関数（OVER句）により累積合計を求めることができる。"
        },
        {
          "id": "q2-20",
          "type": "single_choice",
          "question": "次のSQL文のうち、ウィンドウ関数を使用して累積合計を求めているものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SELECT SUM(amount) FROM sales GROUP BY month;"
            },
            {
              "value": "b",
              "text": "SELECT amount, SUM(amount) OVER (ORDER BY sale_date) FROM sales;"
            },
            {
              "value": "c",
              "text": "SELECT amount FROM sales WHERE amount > (SELECT AVG(amount) FROM sales);"
            },
            {
              "value": "d",
              "text": "SELECT * FROM sales WHERE EXISTS (SELECT * FROM refunds WHERE sales.id = refunds.sale_id);"
            }
          ],
          "correct": "b",
          "explanation": "ウィンドウ関数（OVER句）により累積合計を求めることができる。"
        },
        {
          "id": "q2-20",
          "type": "essay",
          "question": "MERGE文の使用例と、業務における具体的な利用シーンについて300字以内で説明せよ。",
          "correct": "",
          "explanation": "MERGE文はUPSERTに使われる。データの更新／挿入を同時に行いたい場合に有効。"
        }
      ]
    },
    {
      "id": "normalization",
      "title": "正規化・データモデリング",
      "questions": [
        {
          "id": "q3-1",
          "type": "single_choice",
          "question": "第1正規形に正しく正規化されたリレーションの特徴として最も適切なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "すべての属性がスカラー値である"
            },
            {
              "value": "b",
              "text": "主キーが複数存在してもよい"
            },
            {
              "value": "c",
              "text": "関数従属性がすべて除去されている"
            },
            {
              "value": "d",
              "text": "全ての属性が主キーに従属している"
            }
          ],
          "correct": "a",
          "explanation": "第1正規形では繰り返し属性を排除し、すべての属性がスカラー値（単一の値）でなければならない。"
        },
        {
          "id": "q3-2",
          "type": "single_choice",
          "question": "次のうち、第2正規形で除去される問題に最も関連するものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "関数従属"
            },
            {
              "value": "b",
              "text": "部分関数従属"
            },
            {
              "value": "c",
              "text": "推移的関数従属"
            },
            {
              "value": "d",
              "text": "多値従属"
            }
          ],
          "correct": "b",
          "explanation": "第2正規形では、主キーの一部にのみ依存する部分関数従属を除去する。"
        },
        {
          "id": "q3-3",
          "type": "single_choice",
          "question": "次のうち、BCNF（ボイス・コッド正規形）で除去されるべき関係の特徴として最も適切なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "すべての関数従属の決定項が候補キーである"
            },
            {
              "value": "b",
              "text": "一部の関数従属の決定項が候補キーでない"
            },
            {
              "value": "c",
              "text": "すべての関数従属が推移的従属である"
            },
            {
              "value": "d",
              "text": "すべての関数従属が冗長である"
            }
          ],
          "correct": "b",
          "explanation": "BCNFは、すべての関数従属の決定項が候補キーであることを要求する。候補キーでない決定項がある場合、BCNF違反となる。"
        },
        {
          "id": "q3-4",
          "type": "multiple_choice",
          "question": "第3正規形に関する特徴として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "第2正規形を満たしている"
            },
            {
              "value": "b",
              "text": "推移的関数従属が存在しない"
            },
            {
              "value": "c",
              "text": "部分関数従属が存在する"
            },
            {
              "value": "d",
              "text": "候補キー以外の属性が決定項となっている"
            },
            {
              "value": "e",
              "text": "冗長なデータを許容する"
            }
          ],
          "correct": [
            "a",
            "b"
          ],
          "explanation": "第3正規形は第2正規形を満たし、かつ推移的関数従属を排除する。"
        },
        {
          "id": "q3-5",
          "type": "essay",
          "question": "実業務で第3正規形まで正規化することの利点と欠点を、それぞれ具体例を交えて300字以内で説明せよ。",
          "correct": "",
          "explanation": "第3正規形は冗長性を排除し整合性を保てるが、結合回数が増えパフォーマンスに影響を与える可能性がある。"
        },
        {
          "id": "q3-6",
          "type": "single_choice",
          "question": "関数従属A→Bが存在し、Aが候補キーである場合、Bに関する説明として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "Bは必ずAに関係なく一意である"
            },
            {
              "value": "b",
              "text": "BはAの属性値に一意に対応する"
            },
            {
              "value": "c",
              "text": "BはAと同じ属性である"
            },
            {
              "value": "d",
              "text": "BはAの部分集合である"
            }
          ],
          "correct": "b",
          "explanation": "関数従属A→Bは、Aの値が決まればBの値も一意に決まることを意味する。"
        },
        {
          "id": "q3-7",
          "type": "single_choice",
          "question": "次のうち、E-R図における多対多の関係を正規化する場合の正しい対応方法はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "主キーを複製する"
            },
            {
              "value": "b",
              "text": "中間テーブルを導入する"
            },
            {
              "value": "c",
              "text": "1対1の関係に分割する"
            },
            {
              "value": "d",
              "text": "全属性を1つのテーブルに統合する"
            }
          ],
          "correct": "b",
          "explanation": "多対多の関係は中間テーブル（交差テーブル）を設けて表現する。"
        },
        {
          "id": "q3-8",
          "type": "single_choice",
          "question": "次のうち、正規化を進めすぎた結果として起こりやすい問題はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "データの重複が増える"
            },
            {
              "value": "b",
              "text": "データの整合性が失われる"
            },
            {
              "value": "c",
              "text": "結合回数が増えてクエリ性能が低下する"
            },
            {
              "value": "d",
              "text": "一意性制約を設けられなくなる"
            }
          ],
          "correct": "c",
          "explanation": "過度の正規化によりテーブルが細分化され、JOIN回数が増加しパフォーマンス低下を招くことがある。"
        },
        {
          "id": "q3-9",
          "type": "multiple_choice",
          "question": "正規化の目的として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "データの整合性を保つ"
            },
            {
              "value": "b",
              "text": "データベースのアクセス速度を高める"
            },
            {
              "value": "c",
              "text": "冗長性を排除する"
            },
            {
              "value": "d",
              "text": "トランザクション数を増やす"
            },
            {
              "value": "e",
              "text": "更新時の異常を防ぐ"
            }
          ],
          "correct": [
            "a",
            "c",
            "e"
          ],
          "explanation": "正規化は主に整合性確保・冗長性排除・更新異常の回避を目的とする。"
        },
        {
          "id": "q3-10",
          "type": "essay",
          "question": "データモデリングにおいて主キー選定の考慮点と、自然キーと代理キーの利点・欠点について300字以内で述べよ。",
          "choices": [
            {
              "value": "a",
              "text": "Bは必ずAに関係なく一意である"
            },
            {
              "value": "b",
              "text": "BはAの属性値に一意に対応する"
            },
            {
              "value": "c",
              "text": "BはAと同じ属性である"
            },
            {
              "value": "d",
              "text": "BはAの部分集合である"
            }
          ],
          "correct": "",
          "explanation": "自然キーは意味を持つが変更リスクがあり、代理キーは安定性があるが業務上の意味を持たないなど、それぞれの特徴がある。"
        },
        {
          "id": "q3-11",
          "type": "single_choice",
          "question": "第1正規形の要件として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "すべての非キー属性が候補キーの一部にのみ依存する"
            },
            {
              "value": "b",
              "text": "すべての非キー属性が候補キー全体に完全関数従属している"
            },
            {
              "value": "c",
              "text": "非キー属性が他の非キー属性に依存する"
            },
            {
              "value": "d",
              "text": "すべての属性が主キーである"
            }
          ],
          "correct": "b",
          "explanation": "第2正規形では、すべての非キー属性が候補キー全体に完全に関数従属している必要がある。"
        },
        {
          "id": "q3-12",
          "type": "single_choice",
          "question": "次のうち、第4正規形で取り扱うべきデータ構造上の問題はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "推移的関数従属"
            },
            {
              "value": "b",
              "text": "多値従属"
            },
            {
              "value": "c",
              "text": "部分関数従属"
            },
            {
              "value": "d",
              "text": "候補キーの重複"
            }
          ],
          "correct": "b",
          "explanation": "第4正規形では多値従属を排除する。これは一つの主キーに対して複数の独立した値が対応する場合。"
        },
        {
          "id": "q3-13",
          "type": "single_choice",
          "question": "第5正規形（PJ/NF）における主な目的はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "推移的従属の排除"
            },
            {
              "value": "b",
              "text": "多値従属の排除"
            },
            {
              "value": "c",
              "text": "結合従属性の排除"
            },
            {
              "value": "d",
              "text": "関数従属の排除"
            }
          ],
          "correct": "c",
          "explanation": "第5正規形では結合従属性（join dependency）を排除し、すべての情報が損失なく再構成できるようにする。"
        },
        {
          "id": "q3-14",
          "type": "single_choice",
          "question": "第4正規形の要件として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "すべての非キー属性が候補キーの一部にのみ依存する"
            },
            {
              "value": "b",
              "text": "すべての非キー属性が候補キー全体に完全関数従属している"
            },
            {
              "value": "c",
              "text": "非キー属性が他の非キー属性に依存する"
            },
            {
              "value": "d",
              "text": "すべての属性が主キーである"
            }
          ],
          "correct": "b",
          "explanation": "第2正規形では、すべての非キー属性が候補キー全体に完全に関数従属している必要がある。"
        },
        {
          "id": "q3-15",
          "type": "single_choice",
          "question": "第5正規形の要件として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "すべての非キー属性が候補キーの一部にのみ依存する"
            },
            {
              "value": "b",
              "text": "すべての非キー属性が候補キー全体に完全関数従属している"
            },
            {
              "value": "c",
              "text": "非キー属性が他の非キー属性に依存する"
            },
            {
              "value": "d",
              "text": "すべての属性が主キーである"
            }
          ],
          "correct": "b",
          "explanation": "第2正規形では、すべての非キー属性が候補キー全体に完全に関数従属している必要がある。"
        },
        {
          "id": "q3-16",
          "type": "single_choice",
          "question": "第6正規形の要件として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "すべての非キー属性が候補キーの一部にのみ依存する"
            },
            {
              "value": "b",
              "text": "すべての非キー属性が候補キー全体に完全関数従属している"
            },
            {
              "value": "c",
              "text": "非キー属性が他の非キー属性に依存する"
            },
            {
              "value": "d",
              "text": "すべての属性が主キーである"
            }
          ],
          "correct": "b",
          "explanation": "第2正規形では、すべての非キー属性が候補キー全体に完全に関数従属している必要がある。"
        },
        {
          "id": "q3-17",
          "type": "multiple_choice",
          "question": "次のうち、正規化が適用されたデータモデルの利点として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "冗長性の排除"
            },
            {
              "value": "b",
              "text": "更新時の整合性確保"
            },
            {
              "value": "c",
              "text": "物理設計の自由度の向上"
            },
            {
              "value": "d",
              "text": "問合せ回数の削減"
            },
            {
              "value": "e",
              "text": "結合演算の不要化"
            }
          ],
          "correct": [
            "a",
            "b",
            "c"
          ],
          "explanation": "正規化は論理整合性の確保と冗長性排除に寄与するが、結合はむしろ必要になるケースが多い。"
        },
        {
          "id": "q3-18",
          "type": "multiple_choice",
          "question": "次のうち、データモデリング時に発生する課題として適切なものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "業務要件との乖離"
            },
            {
              "value": "b",
              "text": "正規化の過不足"
            },
            {
              "value": "c",
              "text": "ビューの性能問題"
            },
            {
              "value": "d",
              "text": "インデックスの設計不備"
            },
            {
              "value": "e",
              "text": "非正規形の過度利用"
            }
          ],
          "correct": [
            "a",
            "b",
            "e"
          ],
          "explanation": "データモデリングでは、要件との整合性や正規化の程度が重要であり、非正規形の利用にも注意が必要。"
        },
        {
          "id": "q3-19",
          "type": "essay",
          "question": "非正規形をあえて採用するケースについて、具体的な業務例を挙げて300字以内で述べよ。",
          "correct": "",
          "explanation": "パフォーマンスや柔軟性を優先する場合、非正規形が利用されることがある。"
        },
        {
          "id": "q3-20",
          "type": "essay",
          "question": "関数従属と推移的関数従属の違いについて、具体例を交えて説明せよ。",
          "correct": "",
          "explanation": "関数従属は1対1対応を表し、推移的従属は中間項を介して従属が成立する場合を指す。"
        }
      ]
    },
    {
      "id": "performance",
      "title": "性能・チューニング",
      "questions": [
        {
          "id": "q4-1",
          "type": "single_choice",
          "question": "インデックスを活用することで得られる主な利点はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "テーブルの更新速度が向上する"
            },
            {
              "value": "b",
              "text": "ディスク使用量が削減される"
            },
            {
              "value": "c",
              "text": "検索条件によるデータ抽出が高速化される"
            },
            {
              "value": "d",
              "text": "データベースの正規化が進む"
            }
          ],
          "correct": "c",
          "explanation": "インデックスは検索条件によるデータ抽出を高速化する。更新処理には逆に影響を与える場合がある。"
        },
        {
          "id": "q4-2",
          "type": "single_choice",
          "question": "次のうち、B+木インデックスの特徴として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "親ノードにデータが格納される"
            },
            {
              "value": "b",
              "text": "すべての検索はルートから葉までたどる"
            },
            {
              "value": "c",
              "text": "キーはランダムに格納される"
            },
            {
              "value": "d",
              "text": "構造は挿入・削除により不変である"
            }
          ],
          "correct": "b",
          "explanation": "B+木ではすべての検索はルートノードから葉ノードまでをたどる構造をとる。"
        },
        {
          "id": "q4-3",
          "type": "single_choice",
          "question": "実行計画に含まれる内容として最も適切なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "SQL文の形式"
            },
            {
              "value": "b",
              "text": "問い合わせの目的"
            },
            {
              "value": "c",
              "text": "データ取得に使用されるアクセスパス"
            },
            {
              "value": "d",
              "text": "データベース全体の構成"
            }
          ],
          "correct": "c",
          "explanation": "実行計画は、問い合わせを処理する際に使用するインデックスや結合方法などの情報を含む。"
        },
        {
          "id": "q4-4",
          "type": "single_choice",
          "question": "クエリパフォーマンスを改善するための方法として適切でないものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "必要な列だけをSELECT句に指定する"
            },
            {
              "value": "b",
              "text": "WHERE句で条件を絞り込む"
            },
            {
              "value": "c",
              "text": "SELECT * を多用する"
            },
            {
              "value": "d",
              "text": "インデックスの利用を促す条件を使う"
            }
          ],
          "correct": "c",
          "explanation": "SELECT * は不要な列も含めてしまうため、パフォーマンスの低下を招く可能性がある。"
        },
        {
          "id": "q4-5",
          "type": "single_choice",
          "question": "パーティショニングの利点として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "論理的整合性が強化される"
            },
            {
              "value": "b",
              "text": "検索・集計処理の効率化"
            },
            {
              "value": "c",
              "text": "外部キー制約が強化される"
            },
            {
              "value": "d",
              "text": "トリガー処理の簡素化"
            }
          ],
          "correct": "b",
          "explanation": "パーティショニングにより、特定の範囲のデータに対してだけアクセスできるため、検索や集計の効率が上がる。"
        },
        {
          "id": "q4-6",
          "type": "single_choice",
          "question": "ヒント句（ヒント文）に関する記述として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "クエリの構文を修正するために用いる"
            },
            {
              "value": "b",
              "text": "SQL文に論理演算子を追加する"
            },
            {
              "value": "c",
              "text": "オプティマイザに実行計画の選択を指示する"
            },
            {
              "value": "d",
              "text": "トランザクション制御を補助する"
            }
          ],
          "correct": "c",
          "explanation": "ヒント句はオプティマイザに対して実行計画の選択を意図的に誘導するものである。"
        },
        {
          "id": "q4-7",
          "type": "multiple_choice",
          "question": "データベースチューニングにおいて考慮すべき指標として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "CPU使用率"
            },
            {
              "value": "b",
              "text": "ディスクI/O量"
            },
            {
              "value": "c",
              "text": "ネットワーク遅延"
            },
            {
              "value": "d",
              "text": "論理設計書の行数"
            },
            {
              "value": "e",
              "text": "キャッシュヒット率"
            }
          ],
          "correct": [
            "a",
            "b",
            "c",
            "e"
          ],
          "explanation": "チューニングにおいてはリソース使用率やヒット率などが重要。論理設計書の行数は指標ではない。"
        },
        {
          "id": "q4-8",
          "type": "multiple_choice",
          "question": "インデックスが有効に機能しないケースとして正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "ワイルドカードが前方一致のLIKE"
            },
            {
              "value": "b",
              "text": "関数を使ってWHERE句で比較"
            },
            {
              "value": "c",
              "text": "列にNULLが多い"
            },
            {
              "value": "d",
              "text": "比較演算子で値範囲を指定"
            },
            {
              "value": "e",
              "text": "大量のデータが更新される"
            }
          ],
          "correct": [
            "a",
            "b",
            "c",
            "e"
          ],
          "explanation": "LIKE '%xxx' や関数適用、NULLの多さ、頻繁な更新はインデックスが有効に機能しづらい。"
        },
        {
          "id": "q4-9",
          "type": "essay",
          "question": "SQLのパフォーマンス劣化に繋がるクエリパターンを具体例を挙げて300字以内で説明せよ。",
          "correct": "",
          "explanation": "非SARGable条件、過剰なJOIN、インデックス未使用などがパフォーマンスを低下させる原因となる。"
        },
        {
          "id": "q4-10",
          "type": "essay",
          "question": "データベースでの統計情報の役割と、最新化を怠ることによる影響を説明せよ。",
          "correct": "",
          "explanation": "統計情報はオプティマイザが実行計画を選ぶ際の重要な判断材料であり、古いままだと非効率な計画が選ばれる可能性がある。"
        },
        {
          "id": "q4-11",
          "type": "single_choice",
          "question": "実行計画でNested Loop Joinが選択されやすい状況はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "両テーブルが非常に大規模な場合"
            },
            {
              "value": "b",
              "text": "結合キーにインデックスがある場合"
            },
            {
              "value": "c",
              "text": "結合条件が存在しない場合"
            },
            {
              "value": "d",
              "text": "メモリ使用量を抑えたい場合"
            }
          ],
          "correct": "b",
          "explanation": "Nested Loop Joinは片方のテーブルにインデックスがあると効率的に処理できる。"
        },
        {
          "id": "q4-12",
          "type": "single_choice",
          "question": "Hash Joinにおいて、ハッシュテーブルに格納されるのは通常どのテーブルか。",
          "choices": [
            {
              "value": "a",
              "text": "より小さいテーブル"
            },
            {
              "value": "b",
              "text": "より大きいテーブル"
            },
            {
              "value": "c",
              "text": "ソートされたテーブル"
            },
            {
              "value": "d",
              "text": "インデックスが設定されたテーブル"
            }
          ],
          "correct": "a",
          "explanation": "Hash Joinでは、メモリに収まる小さい方のテーブルをハッシュテーブルに格納する。"
        },
        {
          "id": "q4-13",
          "type": "single_choice",
          "question": "クエリチューニングの際、使用状況がわかるSQL文の実行分析ツールはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "ER図"
            },
            {
              "value": "b",
              "text": "EXPLAIN"
            },
            {
              "value": "c",
              "text": "VACUUM"
            },
            {
              "value": "d",
              "text": "UNION"
            }
          ],
          "correct": "b",
          "explanation": "EXPLAINを使うことで、実行計画を確認し、ボトルネックを分析できる。"
        },
        {
          "id": "q4-14",
          "type": "single_choice",
          "question": "クエリキャッシュが有効に機能する典型的な条件はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "毎回異なるパラメータで実行されるSQL"
            },
            {
              "value": "b",
              "text": "同一SQLが頻繁に発行される場合"
            },
            {
              "value": "c",
              "text": "トランザクションが多く発生する場合"
            },
            {
              "value": "d",
              "text": "INSERT文が連続して実行される場合"
            }
          ],
          "correct": "b",
          "explanation": "同じSQLが繰り返し実行されるとき、クエリキャッシュが効果を発揮する。"
        },
        {
          "id": "q4-15",
          "type": "single_choice",
          "question": "Materialized View（マテリアライズドビュー）の特徴はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "常に最新のデータを保持する"
            },
            {
              "value": "b",
              "text": "定期的な更新や手動更新が必要"
            },
            {
              "value": "c",
              "text": "リアルタイムで更新される"
            },
            {
              "value": "d",
              "text": "データの保持はしない"
            }
          ],
          "correct": "b",
          "explanation": "マテリアライズドビューは実データを保持するため、更新タイミングの制御が必要となる。"
        },
        {
          "id": "q4-16",
          "type": "single_choice",
          "question": "インデックススキャンが利用されにくくなるSQL構文はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "WHERE句に列名 = 値の形式"
            },
            {
              "value": "b",
              "text": "WHERE句に関数適用"
            },
            {
              "value": "c",
              "text": "ORDER BY句の指定"
            },
            {
              "value": "d",
              "text": "GROUP BYの使用"
            }
          ],
          "correct": "b",
          "explanation": "WHERE句で関数を使うとインデックスが活用されにくくなる。"
        },
        {
          "id": "q4-17",
          "type": "multiple_choice",
          "question": "結合処理におけるハッシュ結合の特徴として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "結合キーにインデックスがなくても動作する"
            },
            {
              "value": "b",
              "text": "大規模データ間でも高速に結合できる"
            },
            {
              "value": "c",
              "text": "ハッシュ値に基づく一致確認を行う"
            },
            {
              "value": "d",
              "text": "必ず主キーとの結合に使う"
            },
            {
              "value": "e",
              "text": "メモリに小さいテーブルを展開する必要がある"
            }
          ],
          "correct": [
            "a",
            "b",
            "c",
            "e"
          ],
          "explanation": "ハッシュ結合はインデックス不要で、大規模データにも適用可能だが、片方のテーブルをメモリに展開する必要がある。"
        },
        {
          "id": "q4-18",
          "type": "multiple_choice",
          "question": "実行計画におけるコストが高くなる要因として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "テーブルのフルスキャン"
            },
            {
              "value": "b",
              "text": "インデックススキャンの誤使用"
            },
            {
              "value": "c",
              "text": "結合回数の増加"
            },
            {
              "value": "d",
              "text": "統計情報の未更新"
            },
            {
              "value": "e",
              "text": "ビューの参照"
            }
          ],
          "correct": [
            "a",
            "b",
            "c",
            "d"
          ],
          "explanation": "フルスキャンや不要なインデックス使用、結合の増加、統計情報の未更新はコスト増に繋がる。"
        },
        {
          "id": "q4-19",
          "type": "essay",
          "question": "ビューとマテリアライズドビューの違いについて、300字以内で説明せよ。",
          "correct": "",
          "explanation": "ビューは都度参照時に評価され、マテリアライズドビューは実体として保持される。"
        },
        {
          "id": "q4-20",
          "type": "essay",
          "question": "SQL文が遅い原因を特定する手順と、それに基づいた改善案を300字以内で述べよ。",
          "correct": "",
          "explanation": "EXPLAINで実行計画を確認し、インデックスの有無や結合方法、フィルター条件を調整することが改善につながる。"
        }
      ]
    },
    {
      "id": "security",
      "title": "セキュリティ",
      "questions": [
        {
          "id": "q5-1",
          "type": "single_choice",
          "question": "SQLインジェクション対策として最も基本的な方法はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "データベースのバックアップを頻繁に取得する"
            },
            {
              "value": "b",
              "text": "入力値をプリペアドステートメントで処理する"
            },
            {
              "value": "c",
              "text": "SELECT文を使用しない"
            },
            {
              "value": "d",
              "text": "Webサーバのログを定期的に確認する"
            }
          ],
          "correct": "b",
          "explanation": "プリペアドステートメントを使うことで、入力値をSQLとして解釈させないようにする。"
        },
        {
          "id": "q5-2",
          "type": "single_choice",
          "question": "次のうち、アクセス制御方式のうちロールベースアクセス制御(RBAC)に該当するのはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "ユーザ単位で明示的に許可を与える"
            },
            {
              "value": "b",
              "text": "データへのアクセス記録を残す"
            },
            {
              "value": "c",
              "text": "ユーザに割り当てた役割に応じて権限を与える"
            },
            {
              "value": "d",
              "text": "アクセスが失敗した回数を記録する"
            }
          ],
          "correct": "c",
          "explanation": "RBACではユーザにロールを割り当て、そのロールに基づいてアクセス権を付与する。"
        },
        {
          "id": "q5-3",
          "type": "single_choice",
          "question": "暗号化通信に使用されるSSL/TLSの主な目的はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "ファイルの圧縮"
            },
            {
              "value": "b",
              "text": "サーバの高速化"
            },
            {
              "value": "c",
              "text": "通信内容の盗聴防止"
            },
            {
              "value": "d",
              "text": "トランザクション処理の効率化"
            }
          ],
          "correct": "c",
          "explanation": "SSL/TLSは通信内容を暗号化し、第三者による盗聴を防ぐ技術である。"
        },
        {
          "id": "q5-4",
          "type": "single_choice",
          "question": "データベースにおける監査ログの目的として最も適切なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "ディスク容量の節約"
            },
            {
              "value": "b",
              "text": "アクセス操作の記録と追跡"
            },
            {
              "value": "c",
              "text": "バックアップ頻度の低減"
            },
            {
              "value": "d",
              "text": "ネットワーク通信の高速化"
            }
          ],
          "correct": "b",
          "explanation": "監査ログはユーザの操作履歴を記録し、不正アクセスの検出や追跡に使用される。"
        },
        {
          "id": "q5-5",
          "type": "single_choice",
          "question": "次のうち、SQLインジェクション攻撃に該当するものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "フォームのパスワード入力欄を連打する"
            },
            {
              "value": "b",
              "text": "HTMLにJavaScriptコードを埋め込む"
            },
            {
              "value": "c",
              "text": "入力値に ' OR '1'='1 を含めてログインを試みる"
            },
            {
              "value": "d",
              "text": "画像ファイルを大量アップロードする"
            }
          ],
          "correct": "c",
          "explanation": "SQLインジェクションではSQL構文を不正に挿入することで、意図しない動作を引き起こす。"
        },
        {
          "id": "q5-6",
          "type": "single_choice",
          "question": "公開鍵暗号方式における公開鍵の使用目的として適切なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "データベースの最適化"
            },
            {
              "value": "b",
              "text": "受信者のみが復号できるように暗号化する"
            },
            {
              "value": "c",
              "text": "送信者の署名を生成する"
            },
            {
              "value": "d",
              "text": "復号専用に使用される"
            }
          ],
          "correct": "b",
          "explanation": "公開鍵は暗号化に使用され、秘密鍵を持つ受信者のみが復号できる。"
        },
        {
          "id": "q5-7",
          "type": "multiple_choice",
          "question": "SQLインジェクションへの有効な対策として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "プリペアドステートメントの使用"
            },
            {
              "value": "b",
              "text": "入力値のサニタイズ"
            },
            {
              "value": "c",
              "text": "動的SQLの多用"
            },
            {
              "value": "d",
              "text": "アプリケーション層での入力バリデーション"
            },
            {
              "value": "e",
              "text": "すべての入力値をHTMLエスケープする"
            }
          ],
          "correct": [
            "a",
            "b",
            "d"
          ],
          "explanation": "SQLインジェクション対策には、プリペアドステートメント、入力値のチェック、アプリケーションレベルの対策が有効である。"
        },
        {
          "id": "q5-8",
          "type": "multiple_choice",
          "question": "データベースにおけるアクセス制御方式として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "MAC（強制アクセス制御）"
            },
            {
              "value": "b",
              "text": "DAC（任意アクセス制御）"
            },
            {
              "value": "c",
              "text": "RBAC（ロールベースアクセス制御）"
            },
            {
              "value": "d",
              "text": "SAC（セッションベースアクセス制御）"
            },
            {
              "value": "e",
              "text": "PAC（プロセスアクセス制御）"
            }
          ],
          "correct": [
            "a",
            "b",
            "c"
          ],
          "explanation": "MAC・DAC・RBACはいずれも代表的なアクセス制御方式である。"
        },
        {
          "id": "q5-9",
          "type": "essay",
          "question": "データベースにおける監査ログの重要性と、その活用方法について300字以内で説明せよ。",
          "correct": "",
          "explanation": "監査ログはアクセス記録を残すことで、不正検知・事後追跡・コンプライアンス対応に役立つ。"
        },
        {
          "id": "q5-10",
          "type": "essay",
          "question": "暗号化された通信とデータベースへのアクセスにおけるセキュリティ強化策について、具体例を挙げて300字以内で説明せよ。",
          "correct": "",
          "explanation": "SSL/TLSによる通信路の暗号化、DBアクセス制限、パスワードポリシー、IP制限などがある。"
        },
        {
          "id": "q5-11",
          "type": "single_choice",
          "question": "パスワード管理において、安全性を高める方法として最も適切なのはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "定期的にパスワードを共有する"
            },
            {
              "value": "b",
              "text": "パスワードを平文で保存する"
            },
            {
              "value": "c",
              "text": "ソルト付きハッシュ化して保存する"
            },
            {
              "value": "d",
              "text": "パスワードをブラウザに保存する"
            }
          ],
          "correct": "c",
          "explanation": "パスワードはソルトを用いたハッシュ化で保存することで漏洩時のリスクを軽減できる。"
        },
        {
          "id": "q5-12",
          "type": "single_choice",
          "question": "データベースにおいて、最小権限の原則（Principle of Least Privilege）が意味することはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "全ユーザに管理者権限を与える"
            },
            {
              "value": "b",
              "text": "ユーザに必要最小限の権限のみ与える"
            },
            {
              "value": "c",
              "text": "すべてのユーザを一つのロールにまとめる"
            },
            {
              "value": "d",
              "text": "アクセスログを残さない"
            }
          ],
          "correct": "b",
          "explanation": "最小権限の原則とは、ユーザに必要最低限の権限のみを付与し、セキュリティリスクを下げる設計原則である。"
        },
        {
          "id": "q5-13",
          "type": "single_choice",
          "question": "データベースに対するDoS攻撃への対策として適切なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "IPアドレス制限や接続数制限を行う"
            },
            {
              "value": "b",
              "text": "すべてのデータを公開する"
            },
            {
              "value": "c",
              "text": "ログを削除する"
            },
            {
              "value": "d",
              "text": "CPU使用率を制限しない"
            }
          ],
          "correct": "a",
          "explanation": "DoS攻撃対策としては、IP制限や同時接続数制限、レートリミットなどの設定が有効である。"
        },
        {
          "id": "q5-14",
          "type": "single_choice",
          "question": "多要素認証（MFA）の構成要素に含まれないものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "知識要素（パスワード）"
            },
            {
              "value": "b",
              "text": "所持要素（スマートフォン）"
            },
            {
              "value": "c",
              "text": "生体要素（指紋など）"
            },
            {
              "value": "d",
              "text": "ユーザの所属部署"
            }
          ],
          "correct": "d",
          "explanation": "MFAは「知識」「所持」「生体」など複数の認証要素を組み合わせて本人確認を強化する。"
        },
        {
          "id": "q5-15",
          "type": "single_choice",
          "question": "SQLインジェクションの検出方法として有効なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "セッション情報を暗号化する"
            },
            {
              "value": "b",
              "text": "エラーログやアクセスログの監視"
            },
            {
              "value": "c",
              "text": "ファイルシステムの暗号化"
            },
            {
              "value": "d",
              "text": "GUIベースの管理ツールを使用する"
            }
          ],
          "correct": "b",
          "explanation": "不正なパラメータや想定外のSQLが実行された場合のログを監視することで検出可能となる。"
        },
        {
          "id": "q5-16",
          "type": "single_choice",
          "question": "アクセスログから不正アクセスを早期発見するために重要なのはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "定期的なログの監査"
            },
            {
              "value": "b",
              "text": "ログを保存しない"
            },
            {
              "value": "c",
              "text": "ログを暗号化しない"
            },
            {
              "value": "d",
              "text": "1年に1回だけログを確認する"
            }
          ],
          "correct": "a",
          "explanation": "定期的にログを監査することで、早期に異常を発見することができる。"
        },
        {
          "id": "q5-17",
          "type": "multiple_choice",
          "question": "暗号化の目的として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "データの秘匿性の確保"
            },
            {
              "value": "b",
              "text": "データの完全性の検証"
            },
            {
              "value": "c",
              "text": "通信の傍受防止"
            },
            {
              "value": "d",
              "text": "パフォーマンスの向上"
            },
            {
              "value": "e",
              "text": "送信者の認証"
            }
          ],
          "correct": [
            "a",
            "b",
            "c",
            "e"
          ],
          "explanation": "暗号化は主に秘匿性、完全性、認証、傍受防止の目的で用いられる。"
        },
        {
          "id": "q5-18",
          "type": "multiple_choice",
          "question": "データベースへの不正アクセスを防止するための対策として有効なものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "SQL文のログ出力"
            },
            {
              "value": "b",
              "text": "アカウントごとの接続制限"
            },
            {
              "value": "c",
              "text": "ファイアウォールによる接続制御"
            },
            {
              "value": "d",
              "text": "スーパーユーザ権限の一元化"
            },
            {
              "value": "e",
              "text": "OSのアップデートの停止"
            }
          ],
          "correct": [
            "a",
            "b",
            "c",
            "d"
          ],
          "explanation": "接続制限・ログ監視・権限制御・ネットワーク制御などは不正アクセスの対策となる。"
        },
        {
          "id": "q5-19",
          "type": "essay",
          "question": "データベースのパスワード管理におけるリスクと、それを軽減するための対策について300字以内で述べよ。",
          "correct": "",
          "explanation": "パスワードの平文保存、使い回し、弱いパスワードはリスクとなる。ソルト付きハッシュ化や長く複雑なパスワードが対策となる。"
        },
        {
          "id": "q5-20",
          "type": "essay",
          "question": "アクセス制御の実装時におけるRBACの利点と注意点について、300字以内で説明せよ。",
          "correct": "",
          "explanation": "RBACはユーザごとに権限を設定せずに済む利点があるが、ロール設計を慎重に行わないと過剰な権限を許すリスクがある。"
        }
      ]
    },
    {
      "id": "transaction",
      "title": "トランザクション・同期処理",
      "questions": [
        {
          "id": "q6-1",
          "type": "single_choice",
          "question": "トランザクションのACID特性のうち、「一貫性 (Consistency)」に該当する説明はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "処理がすべて完了するか、何も反映されないこと"
            },
            {
              "value": "b",
              "text": "同時実行でも結果が直列化可能であること"
            },
            {
              "value": "c",
              "text": "整合性制約を満たす状態に保たれること"
            },
            {
              "value": "d",
              "text": "トランザクションが永続的に保存されること"
            }
          ],
          "correct": "c",
          "explanation": "一貫性は、トランザクション後も整合性制約が保たれていることを意味する。"
        },
        {
          "id": "q6-2",
          "type": "single_choice",
          "question": "次のうち、デッドロックが発生する可能性がある状況として最も適切なのはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "1つのトランザクションが1つの行だけをロックする場合"
            },
            {
              "value": "b",
              "text": "複数のトランザクションが互いにリソースを待ち合っている場合"
            },
            {
              "value": "c",
              "text": "コミットを行う前に全ての処理が終了している場合"
            },
            {
              "value": "d",
              "text": "トランザクションの分離レベルが低い場合"
            }
          ],
          "correct": "b",
          "explanation": "複数のトランザクションが互いにロックしたリソースを待っていると、デッドロックが発生する。"
        },
        {
          "id": "q6-3",
          "type": "single_choice",
          "question": "トランザクションの分離レベル「READ COMMITTED」で防止できる問題はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "ダーティリード"
            },
            {
              "value": "b",
              "text": "ファントムリード"
            },
            {
              "value": "c",
              "text": "リピートリード"
            },
            {
              "value": "d",
              "text": "すべての読み取りに対する一貫性確保"
            }
          ],
          "correct": "a",
          "explanation": "READ COMMITTEDでは、未コミットのデータの読み取り（ダーティリード）を防止できる。"
        },
        {
          "id": "q6-4",
          "type": "single_choice",
          "question": "2フェーズロック（2PL）の特徴として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "ロックは逐次取得・解放を繰り返す"
            },
            {
              "value": "b",
              "text": "ロックの取得と解放を2段階に分けて制御する"
            },
            {
              "value": "c",
              "text": "ロック解放前に新たなロックを取得できる"
            },
            {
              "value": "d",
              "text": "トランザクションのコミットに関係なくすぐにロックが解放される"
            }
          ],
          "correct": "b",
          "explanation": "2PLは、取得フェーズと解放フェーズを明確に分離し、直列化可能性を保証する。"
        },
        {
          "id": "q6-5",
          "type": "single_choice",
          "question": "トランザクションログの主な用途として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "問い合わせ結果のキャッシュ"
            },
            {
              "value": "b",
              "text": "SQL構文の整形"
            },
            {
              "value": "c",
              "text": "障害時のリカバリ"
            },
            {
              "value": "d",
              "text": "データベースの自動拡張"
            }
          ],
          "correct": "c",
          "explanation": "トランザクションログは、障害時のロールフォワードやロールバックに用いられる。"
        },
        {
          "id": "q6-6",
          "type": "single_choice",
          "question": "トランザクションの「原子性」が意味することはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "操作が順番に実行されること"
            },
            {
              "value": "b",
              "text": "トランザクションのすべての処理が成功するか、すべて取り消されること"
            },
            {
              "value": "c",
              "text": "読み取り専用であること"
            },
            {
              "value": "d",
              "text": "読み取りと書き込みを交互に行うこと"
            }
          ],
          "correct": "b",
          "explanation": "原子性は、トランザクションがすべて完了するか、まったく反映されないことを保証する。"
        },
        {
          "id": "q6-7",
          "type": "multiple_choice",
          "question": "トランザクション分離レベル「SERIALIZABLE」が防止できる問題として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "ダーティリード"
            },
            {
              "value": "b",
              "text": "リピートリード"
            },
            {
              "value": "c",
              "text": "ファントムリード"
            },
            {
              "value": "d",
              "text": "デッドロック"
            },
            {
              "value": "e",
              "text": "ロストアップデート"
            }
          ],
          "correct": [
            "a",
            "b",
            "c"
          ],
          "explanation": "SERIALIZABLEは最も厳格な分離レベルで、ダーティリード、リピートリード、ファントムリードを防ぐ。"
        },
        {
          "id": "q6-8",
          "type": "multiple_choice",
          "question": "次のうち、トランザクションの整合性を確保するために必要な要素をすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "適切なロック制御"
            },
            {
              "value": "b",
              "text": "トランザクションログの記録"
            },
            {
              "value": "c",
              "text": "冗長なSQL文"
            },
            {
              "value": "d",
              "text": "分離レベルの設定"
            },
            {
              "value": "e",
              "text": "キャッシュの無効化"
            }
          ],
          "correct": [
            "a",
            "b",
            "d"
          ],
          "explanation": "ロック制御、ログ記録、分離レベル設定がトランザクションの整合性確保に必要。"
        },
        {
          "id": "q6-9",
          "type": "essay",
          "question": "デッドロックの発生原因と、それを回避または解消するための手法について300字以内で説明せよ。",
          "correct": "",
          "explanation": "互いにロックを取り合って待ち続けることで発生。タイムアウト、ロック順序の統一、デッドロック検出機能の活用などが対策。"
        },
        {
          "id": "q6-10",
          "type": "essay",
          "question": "ACID特性の4つの要素について、それぞれの意味と重要性を300字以内で説明せよ。",
          "correct": "",
          "explanation": "原子性、整合性、独立性、永続性の特性があり、信頼性の高いトランザクション処理を実現するために必要。"
        },
        {
          "id": "q6-11",
          "type": "single_choice",
          "question": "READ UNCOMMITTED 分離レベルにおける問題点として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "ファントムリードが発生しない"
            },
            {
              "value": "b",
              "text": "ダーティリードが発生する"
            },
            {
              "value": "c",
              "text": "整合性制約を強制する"
            },
            {
              "value": "d",
              "text": "デッドロックを防ぐ"
            }
          ],
          "correct": "b",
          "explanation": "READ UNCOMMITTEDでは、他のトランザクションがコミットしていないデータを読み取ってしまう（ダーティリード）。"
        },
        {
          "id": "q6-12",
          "type": "single_choice",
          "question": "MVCC（Multi-Version Concurrency Control）を利用する目的はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "読み取り時にロックを強制する"
            },
            {
              "value": "b",
              "text": "すべてのトランザクションで最新のデータを共有する"
            },
            {
              "value": "c",
              "text": "読み取り処理と書き込み処理を競合なく並行させる"
            },
            {
              "value": "d",
              "text": "トランザクションを逐次実行する"
            }
          ],
          "correct": "c",
          "explanation": "MVCCはスナップショットを用いることで読み取りと書き込みの競合を回避し、並行性を高める。"
        },
        {
          "id": "q6-13",
          "type": "single_choice",
          "question": "ロック待ちによってシステム全体のスループットが低下する現象を何というか？",
          "choices": [
            {
              "value": "a",
              "text": "ロストアップデート"
            },
            {
              "value": "b",
              "text": "デッドロック"
            },
            {
              "value": "c",
              "text": "スラッシング"
            },
            {
              "value": "d",
              "text": "スケーラビリティ"
            }
          ],
          "correct": "b",
          "explanation": "トランザクションが互いのロック解放を待って停止状態になることでスループットが著しく低下する。"
        },
        {
          "id": "q6-14",
          "type": "single_choice",
          "question": "排他制御が行われない場合に発生しうる現象はどれか。",
          "choices": [
            {
              "value": "a",
              "text": "リピートリードの防止"
            },
            {
              "value": "b",
              "text": "整合性の確保"
            },
            {
              "value": "c",
              "text": "ロストアップデート"
            },
            {
              "value": "d",
              "text": "直列化可能性の保証"
            }
          ],
          "correct": "c",
          "explanation": "排他制御がないと同時に更新処理が走り、最後の更新だけが反映されるロストアップデートが起きる。"
        },
        {
          "id": "q6-15",
          "type": "single_choice",
          "question": "トランザクションの永続性（Durability）を実現するために必要なものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "キャッシュの強化"
            },
            {
              "value": "b",
              "text": "ログの記録と確実なディスクへの書き込み"
            },
            {
              "value": "c",
              "text": "排他ロックの短縮"
            },
            {
              "value": "d",
              "text": "データベースのバックアップを削除"
            }
          ],
          "correct": "b",
          "explanation": "永続性はトランザクション完了後に障害が起きても結果が失われないようにする特性。"
        },
        {
          "id": "q6-16",
          "type": "single_choice",
          "question": "ロック粒度（Granularity）が粗い場合の特徴として正しいものはどれか。",
          "choices": [
            {
              "value": "a",
              "text": "同時実行性が高くなる"
            },
            {
              "value": "b",
              "text": "ロック管理が煩雑になる"
            },
            {
              "value": "c",
              "text": "デッドロックのリスクが高まる"
            },
            {
              "value": "d",
              "text": "ロックオーバヘッドが低い"
            }
          ],
          "correct": "d",
          "explanation": "ロック粒度が粗いとロックの数が減り、オーバヘッドは低くなるが同時実行性は下がる。"
        },
        {
          "id": "q6-17",
          "type": "multiple_choice",
          "question": "ファントムリードが発生する可能性がある状況として正しいものをすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "同じ条件で2回SELECTを実行したが、件数が異なる"
            },
            {
              "value": "b",
              "text": "1回目のSELECT後に別トランザクションがデータを追加"
            },
            {
              "value": "c",
              "text": "トランザクション中にDELETEが実行された"
            },
            {
              "value": "d",
              "text": "SELECT文がインデックススキャンを使用している"
            },
            {
              "value": "e",
              "text": "テーブルに行が追加されたがロックされていなかった"
            }
          ],
          "correct": [
            "a",
            "b",
            "e"
          ],
          "explanation": "ファントムリードは、検索条件に合致する新たな行が他のトランザクションで追加されることで発生する。"
        },
        {
          "id": "q6-18",
          "type": "multiple_choice",
          "question": "データベースにおいてスループットを向上させるための一般的な手法をすべて選べ。",
          "choices": [
            {
              "value": "a",
              "text": "ロック粒度の最適化"
            },
            {
              "value": "b",
              "text": "インデックスの活用"
            },
            {
              "value": "c",
              "text": "長時間トランザクションの回避"
            },
            {
              "value": "d",
              "text": "SQLの簡略化"
            },
            {
              "value": "e",
              "text": "同時ユーザ数の制限撤廃"
            }
          ],
          "correct": [
            "a",
            "b",
            "c",
            "d"
          ],
          "explanation": "スループット改善には、ロック制御の工夫、インデックス活用、SQLの効率化が有効。"
        },
        {
          "id": "q6-19",
          "type": "essay",
          "question": "MVCCの仕組みと、同時実行性確保における利点について300字以内で述べよ。",
          "correct": "",
          "explanation": "MVCCは読み取り時にスナップショットを使用することでロックなしで一貫性を保ち、同時実行性を高める。"
        },
        {
          "id": "q6-20",
          "type": "essay",
          "question": "トランザクション分離レベルによる影響と選択の指針について、実運用を考慮して300字以内で説明せよ。",
          "correct": "",
          "explanation": "分離レベルは整合性と性能のトレードオフがあり、要求要件に応じた適切な設定が重要となる。"
        }
      ]
    }
  ]
}