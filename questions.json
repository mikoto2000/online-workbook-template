{
  "sections": [
    {
      "id": "database-design",
      "title": "データベース設計",
      "questions": [
        {
          "type": "single_choice",
          "question": "E-R 図で「1 対多」の多側を表す適切な表記は次のうちどれか。",
          "choices": [
            { "value": "a", "text": "菱形を多側エンティティに付加" },
            { "value": "b", "text": "クロウズフットを多側に描く" },
            { "value": "c", "text": "二重線を多側に描く" },
            { "value": "d", "text": "矢印を多側に向ける" }
          ],
          "correct": "b",
          "explanation": "クロウズフット記法では多側（0..*, 1..* など）に三又の足形を描くことで多重度を示す。"
        },
        {
          "type": "single_choice",
          "question": "物理設計でパーティションキーを選定する主な目的として最も適切なものはどれか。",
          "choices": [
            { "value": "a", "text": "スキーマの可読性向上" },
            { "value": "b", "text": "論理削除の簡素化" },
            { "value": "c", "text": "I/O 並列性と局所性の最適化" },
            { "value": "d", "text": "SQL 文の短縮" }
          ],
          "correct": "c",
          "explanation": "パーティションキーはデータ配置を物理的に分割し、I/O 並列性とキャッシュ局所性を高めるために選定する。"
        },
        {
          "type": "single_choice",
          "question": "外部キー制約を論理設計段階で定義しておく主な利点はどれか。",
          "choices": [
            { "value": "a", "text": "統合テストのコスト削減" },
            { "value": "b", "text": "参照整合性をスキーマで強制できる" },
            { "value": "c", "text": "SQL 文の自動生成が容易" },
            { "value": "d", "text": "アプリケーション側ロジック削減が困難" }
          ],
          "correct": "b",
          "explanation": "外部キー制約は RDBMS が参照整合性を保証するため、設計段階で定義することで不整合データの混入を防止できる。"
        },
        {
          "type": "multiple_choice",
          "question": "概念設計においてエンティティを抽出する際の代表的な手法として適切なものをすべて選べ。",
          "choices": [
            { "value": "a", "text": "名詞抽出法" },
            { "value": "b", "text": "時系列分析法" },
            { "value": "c", "text": "CRUD 行列法" },
            { "value": "d", "text": "トリガベース分析法" },
            { "value": "e", "text": "ダミーデータ生成法" }
          ],
          "correct": ["a", "c"],
          "explanation": "名詞抽出法と CRUD 行列法は実務で広く用いられる。時系列分析はイベント抽出、トリガは運用設計寄りでエンティティ抽出手法とは異なる。"
        },
        {
          "type": "essay",
          "question": "概念設計と論理設計の違いを 300 字以内で説明し、両者の成果物が後続工程に与える影響について述べよ。",
          "correct": "",
          "explanation": "概念設計は業務要件を抽象化しエンティティ・関係を明確化、論理設計は RDBMS 非依存でキーや属性を定義する工程である。後続の物理設計や SQL 実装に直接影響するため理解が重要。"
        },
        {
          "type": "single_choice",
          "question": "E-R 図で強いエンティティと弱いエンティティの違いとして最も適切な説明はどれか。",
          "choices": [
            { "value": "a", "text": "弱いエンティティは主キーを単独で持てず、親エンティティのキーを含む複合キーを持つ" },
            { "value": "b", "text": "弱いエンティティは参照整合性を適用できない" },
            { "value": "c", "text": "強いエンティティは外部キーを持たない" },
            { "value": "d", "text": "強いエンティティは物理設計で必ずインデックスを持つ" }
          ],
          "correct": "a",
          "explanation": "弱いエンティティは独自の主キーを持たず親エンティティの主キーを取り込むため、複合キーで識別される点が強いエンティティと異なる。"
        },
        {
          "type": "single_choice",
          "question": "物理設計においてテーブルをパーティショニングする主目的として最も適切なものはどれか。",
          "choices": [
            { "value": "a", "text": "論理名を短縮するため" },
            { "value": "b", "text": "I/O の並列化とメンテナンス効率の向上を図るため" },
            { "value": "c", "text": "SQL 文を簡潔に記述するため" },
            { "value": "d", "text": "アプリケーションのバージョン管理のため" }
          ],
          "correct": "b",
          "explanation": "パーティショニングはデータを物理的に分割し、I/O 並列性とバックアップ・アーカイブなどの運用効率を高めることが主目的である。"
        },
        {
          "type": "single_choice",
          "question": "概念設計でユースケース駆動法を採用する主な利点として正しいものはどれか。",
          "choices": [
            { "value": "a", "text": "業務フローとエンティティの対応関係を早期に可視化できる" },
            { "value": "b", "text": "SQL チューニング工数を削減できる" },
            { "value": "c", "text": "ストレージコストを即時に算出できる" },
            { "value": "d", "text": "データベース暗号化方式を自動決定できる" }
          ],
          "correct": "a",
          "explanation": "ユースケース駆動法は業務シナリオを起点にエンティティや関係を抽出でき、要件の漏れを防ぎやすい点が大きな利点となる。"
        },
        {
          "type": "multiple_choice",
          "question": "論理設計段階で外部キー制約を設定する効果として適切なものをすべて選べ。",
          "choices": [
            { "value": "a", "text": "参照整合性違反データの登録防止" },
            { "value": "b", "text": "結合クエリ実行時のプラン最適化支援" },
            { "value": "c", "text": "アプリケーション側の入力チェック完全不要化" },
            { "value": "d", "text": "データ削除時のカスケード操作自動化" },
            { "value": "e", "text": "全文検索インデックスの自動生成" }
          ],
          "correct": ["a", "b", "d"],
          "explanation": "外部キーは参照整合性を保証し、統計情報の精度向上でプラン最適化に寄与し、カスケード指定により関連行を自動削除できる。"
        },
        {
          "type": "essay",
          "question": "逆正規化を行う際の判断基準と典型的なパターンについて300字以内で説明せよ。",
          "correct": "",
          "explanation": "逆正規化は性能要件や集計効率を優先して冗長化を許容する設計手法であり、読取頻度が極端に高い参照テーブルの複写などが代表例になる。"
        }
      ]
    },
    {
      "id": "sql",
      "title": "SQL",
      "questions": [
        {
          "type": "single_choice",
          "question": "ウィンドウ関数 ROW_NUMBER() の主な用途として正しいものはどれか。",
          "choices": [
            { "value": "a", "text": "行をランダムに抽出する" },
            { "value": "b", "text": "パーティション内で順位を付与する" },
            { "value": "c", "text": "複数列の NULL を置換する" },
            { "value": "d", "text": "JSON をパースする" }
          ],
          "correct": "b",
          "explanation": "ROW_NUMBER() は PARTITION BY と ORDER BY で区切ったパーティション内に連番を付与するウィンドウ関数である。"
        },
        {
          "type": "single_choice",
          "question": "PostgreSQL などで JSON 列からキー \"price\" を数値として抽出する SQL 例として適切なのはどれか。",
          "choices": [
            { "value": "a", "text": "SELECT price::json FROM items;" },
            { "value": "b", "text": "SELECT items->>'price'::numeric FROM items;" },
            { "value": "c", "text": "SELECT (items->>'price')::numeric FROM items;" },
            { "value": "d", "text": "SELECT json_extract(price) FROM items;" }
          ],
          "correct": "c",
          "explanation": "->> でテキスト抽出後にキャスト ( ... )::numeric する。選択肢 b はキャスト位置が誤り。"
        },
        {
          "type": "single_choice",
          "question": "SQL92 で定義された外部結合のうち FULL OUTER JOIN の結果について正しい説明はどれか。",
          "choices": [
            { "value": "a", "text": "結合条件を満たす行のみを返す" },
            { "value": "b", "text": "左テーブルの全行と一致行を返す" },
            { "value": "c", "text": "両テーブルの全行を返し一致しない側は NULL" },
            { "value": "d", "text": "右テーブルの全行と一致行を返す" }
          ],
          "correct": "c",
          "explanation": "FULL OUTER JOIN は LEFT と RIGHT の和集合であり、どちらにも一致しない側の列は NULL を返す。"
        },
        {
          "type": "multiple_choice",
          "question": "SQL 標準で定義されるトランザクション分離レベルに含まれるものをすべて選べ。",
          "choices": [
            { "value": "a", "text": "READ UNCOMMITTED" },
            { "value": "b", "text": "READ COMMITTED" },
            { "value": "c", "text": "REPEATABLE READ" },
            { "value": "d", "text": "SERIALIZABLE" },
            { "value": "e", "text": "LINEARIZABLE" }
          ],
          "correct": ["a", "b", "c", "d"],
          "explanation": "SQL 標準は 4 段階 (RU, RC, RR, S) を規定し、LINEARIZABLE は分散 DB で用いられる概念で標準には含まれない。"
        },
        {
          "type": "essay",
          "question": "WITH 句 (共通テーブル式) を用いた再帰クエリの仕組みと実用例について 300 字以内で説明せよ。",
          "correct": "",
          "explanation": "再帰 WITH は UNION ALL と固定名 CTE を用いて階層データを走査できる。階層構造メニュー、組織ツリー集計などで有効。"
        },
        {
          "type": "single_choice",
          "question": "ウィンドウ関数 ROW_NUMBER() を使用して取得できる情報として最も適切なものはどれか。",
          "choices": [
            { "value": "a", "text": "パーティション内で指定順序に基づく連番" },
            { "value": "b", "text": "前行との差分値" },
            { "value": "c", "text": "累積合計" },
            { "value": "d", "text": "行のハッシュ値" }
          ],
          "correct": "a",
          "explanation": "ROW_NUMBER() は PARTITION BY と ORDER BY で区切られた範囲内に 1 からの連番を付与する機能である。"
        },
        {
          "type": "single_choice",
          "question": "PostgreSQL で JSONB 列のキー \"price\" を数値型として抽出する正しい記述はどれか。",
          "choices": [
            { "value": "a", "text": "SELECT price::numeric FROM items;" },
            { "value": "b", "text": "SELECT (data->>'price')::numeric FROM items;" },
            { "value": "c", "text": "SELECT data->'price'::numeric FROM items;" },
            { "value": "d", "text": "SELECT CAST(data#>>'{price}' AS numeric) FROM items;" }
          ],
          "correct": "b",
          "explanation": "->> でテキストとして取り出し、その結果を numeric にキャストするのが正しい方法である。"
        },
        {
          "type": "single_choice",
          "question": "ANSI SQL における MERGE 文の主な用途として正しいものはどれか。",
          "choices": [
            { "value": "a", "text": "条件に応じて INSERT と UPDATE を切り替える upsert 操作" },
            { "value": "b", "text": "ビューを一時的にマテリアライズする" },
            { "value": "c", "text": "トリガの実行タイミングを変更する" },
            { "value": "d", "text": "外部キー制約を一時的に無効化する" }
          ],
          "correct": "a",
          "explanation": "MERGE はマッチした行を UPDATE、マッチしない行を INSERT する upsert 処理を 1 文で実現する。"
        },
        {
          "type": "multiple_choice",
          "question": "SQL 標準で定義されているトランザクション分離レベルをすべて選べ。",
          "choices": [
            { "value": "a", "text": "READ UNCOMMITTED" },
            { "value": "b", "text": "READ COMMITTED" },
            { "value": "c", "text": "REPEATABLE READ" },
            { "value": "d", "text": "SERIALIZABLE" },
            { "value": "e", "text": "LINEARIZABLE" }
          ],
          "correct": ["a", "b", "c", "d"],
          "explanation": "SQL92 では 4 つの分離レベルが規定されており、LINEARIZABLE は分散システム特有の概念で標準外である。"
        },
        {
          "type": "essay",
          "question": "共通テーブル式（WITH 句）を用いた再帰クエリの仕組みと典型的な応用例を300字以内で説明せよ。",
          "correct": "",
          "explanation": "再帰 CTE は UNION ALL で自己参照しながら行を展開し、階層構造の木探索や組織ツリーの集計などで活用される。"
        }
      ]
    },
    {
      "id": "normalization",
      "title": "正規化・データモデリング",
      "questions": [
        {
          "type": "single_choice",
          "question": "第 3 正規形 (3NF) が満たすべき条件として正しいものはどれか。",
          "choices": [
            { "value": "a", "text": "非キー属性が候補キーに完全関数従属" },
            { "value": "b", "text": "非キー属性が他の非キー属性に推移従属" },
            { "value": "c", "text": "全ての決定因子が候補キー" },
            { "value": "d", "text": "主キーが単一列である" }
          ],
          "correct": "a",
          "explanation": "3NF は非キー属性が候補キーに完全関数従属し、かつ非キー属性間に推移従属がない状態を指す。"
        },
        {
          "type": "single_choice",
          "question": "BCNF への変換過程で起こり得る主キーの変化に関する説明として正しいものはどれか。",
          "choices": [
            { "value": "a", "text": "常に主キーが短縮される" },
            { "value": "b", "text": "主キーが複数テーブルに分割される場合がある" },
            { "value": "c", "text": "主キーは変化せずテーブル数だけ増える" },
            { "value": "d", "text": "主キーが外部キーへ自動的に変換される" }
          ],
          "correct": "b",
          "explanation": "BCNF 分解では決定因子を持つ属性群が分離されるため、元の主キーが複数テーブルに分散する場合がある。"
        },
        {
          "type": "single_choice",
          "question": "関数従属性 X→Y が成立する場合の Armstrong 公理に基づく推論として誤っているものはどれか。",
          "choices": [
            { "value": "a", "text": "推移律: X→Z かつ Z→Y なら X→Y" },
            { "value": "b", "text": "拡張律: X→Y なら XZ→YZ" },
            { "value": "c", "text": "合体律: X→Y および X→Z なら X→YZ" },
            { "value": "d", "text": "分解律: X→YZ なら X→Z は導けない" }
          ],
          "correct": "d",
          "explanation": "分解律により X→YZ なら X→Z, X→Y が導けるため「導けない」は誤り。"
        },
        {
          "type": "multiple_choice",
          "question": "次のうち、第 1 正規形 (1NF) を満たしていない状態の例として該当するものをすべて選べ。",
          "choices": [
            { "value": "a", "text": "列に可変長配列を格納" },
            { "value": "b", "text": "繰り返し属性を行で表現" },
            { "value": "c", "text": "複数値属性をカンマ区切りで格納" },
            { "value": "d", "text": "主キーに NULL 値が存在" },
            { "value": "e", "text": "列にスカラー値のみを格納" }
          ],
          "correct": ["a", "c"],
          "explanation": "1NF では列が原子的である必要があり、配列やカンマ区切りで複数値を格納するのは違反。"
        },
        {
          "type": "essay",
          "question": "データウェアハウス設計で 3NF ではなくスター・スキーマが採用される理由と利点を具体例を交えて述べよ (300 字以内)。",
          "correct": "",
          "explanation": "スター・スキーマは結合が単純で集計クエリが高速化するなど BI ツールと相性が良い。論述で詳細を評価。"
        },
        {
          "type": "single_choice",
          "question": "第3正規形 (3NF) を満たす条件として最も適切なものはどれか。",
          "choices": [
            { "value": "a", "text": "非キー属性が候補キーに完全関数従属し、推移従属がない" },
            { "value": "b", "text": "主キーが単一列である" },
            { "value": "c", "text": "全ての関数従属性がトリビアルである" },
            { "value": "d", "text": "多値従属性が存在しない" }
          ],
          "correct": "a",
          "explanation": "3NF は非キー属性が候補キーに完全従属し、非キー属性間の推移従属が排除されている状態をいう。"
        },
        {
          "type": "single_choice",
          "question": "BCNF に正規化する過程で起こり得る現象として適切なものはどれか。",
          "choices": [
            { "value": "a", "text": "テーブルが分割され、元の主キーが複数テーブルに分散する" },
            { "value": "b", "text": "必ずテーブル数が減少する" },
            { "value": "c", "text": "すべての外部キー制約が削除される" },
            { "value": "d", "text": "多値従属性が追加される" }
          ],
          "correct": "a",
          "explanation": "BCNF 分解では決定因子を分離するため、主キーを構成する列が複数テーブルにまたがる場合がある。"
        },
        {
          "type": "single_choice",
          "question": "関数従属性 X→Y があるとき、Armstrong 公理によって必ず導ける推論として正しいものはどれか。",
          "choices": [
            { "value": "a", "text": "拡張律により XZ→YZ が成立する" },
            { "value": "b", "text": "合体律により Y→X が成立する" },
            { "value": "c", "text": "分解律により XY→X が成立する" },
            { "value": "d", "text": "推移律により Z→Y が成立する" }
          ],
          "correct": "a",
          "explanation": "拡張律は右辺と左辺両方に同じ属性集合 Z を付加しても従属性が成立することを保証する。"
        },
        {
          "type": "multiple_choice",
          "question": "第1正規形 (1NF) を満たしていないテーブル設計例をすべて選べ。",
          "choices": [
            { "value": "a", "text": "列に配列型で複数値を格納している" },
            { "value": "b", "text": "複数列を使って複合主キーを構成している" },
            { "value": "c", "text": "列に可変長文字列を格納している" },
            { "value": "d", "text": "列にカンマ区切りで値を連結している" },
            { "value": "e", "text": "テーブルに外部キーが存在する" }
          ],
          "correct": ["a", "d"],
          "explanation": "1NF では各列が原子的である必要があり、配列型やカンマ区切りで複数値を格納する設計は違反となる。"
        },
        {
          "type": "essay",
          "question": "スター・スキーマとスノーフレーク・スキーマの違いとそれぞれの利点を具体例を交えて300字以内で述べよ。",
          "correct": "",
          "explanation": "スターは単純な結合で高速集計、スノーフレークは正規化度が高く更新容易など、実運用での使い分けを論述させる。"
        }
      ]
    },
    {
      "id": "performance",
      "title": "性能・チューニング",
      "questions": [
        {
          "type": "single_choice",
          "question": "B+ 木インデックスにおいてリーフノードのみを順次走査する操作はどの SQL 句と最も関係が深いか。",
          "choices": [
            { "value": "a", "text": "ORDER BY" },
            { "value": "b", "text": "GROUP BY" },
            { "value": "c", "text": "HAVING" },
            { "value": "d", "text": "DISTINCT" }
          ],
          "correct": "a",
          "explanation": "B+ 木はリーフノードが順序付き連結リストになっているため ORDER BY の実装で効率的な範囲走査が可能。"
        },
        {
          "type": "single_choice",
          "question": "実行計画で Nested Loop Join が Hash Join より有利になる典型的な条件はどれか。",
          "choices": [
            { "value": "a", "text": "両テーブルとも非常に大きい" },
            { "value": "b", "text": "片方が小さくインデックスが有効" },
            { "value": "c", "text": "両テーブルが同サイズでソート済み" },
            { "value": "d", "text": "ディスクフルスキャンが必要" }
          ],
          "correct": "b",
          "explanation": "Nested Loop は外側が小さく内側にインデックスがある場合に最少 I/O で結合できる。"
        },
        {
          "type": "single_choice",
          "question": "列指向ストレージエンジンが行指向よりも優れる典型的ワークロードはどれか。",
          "choices": [
            { "value": "a", "text": "OLTP の INSERT/UPDATE" },
            { "value": "b", "text": "頻繁なトリガ実行" },
            { "value": "c", "text": "大量データの集計クエリ" },
            { "value": "d", "text": "ランダム行単独取得" }
          ],
          "correct": "c",
          "explanation": "列指向は必要列のみ連続的に読み込めるため集計・分析系 (OLAP) に特に効果を発揮する。"
        },
        {
          "type": "multiple_choice",
          "question": "次のうち、インデックススキャンを避けてシーケンシャルスキャンを選択する要因として RDBMS が考慮するものをすべて選べ。",
          "choices": [
            { "value": "a", "text": "インデックスのカーディナリティが低い" },
            { "value": "b", "text": "統計情報が古い" },
            { "value": "c", "text": "クエリがワイルドカード前方一致" },
            { "value": "d", "text": "テーブルが極端に小さい" },
            { "value": "e", "text": "ヒープ領域が圧縮されている" }
          ],
          "correct": ["a", "b", "d"],
          "explanation": "低カーディナリティや小テーブルではランダム I/O より全スキャンが速いと判断。統計情報不整合も影響。"
        },
        {
          "type": "essay",
          "question": "レンジパーティショニングとハッシュパーティショニングの特性を比較し、運用面での選択指針を 300 字以内で述べよ。",
          "correct": "",
          "explanation": "レンジは時間系列などで均等分布困難だが管理容易、ハッシュは均等分布しやすいが分割管理が複雑。"
        },
        {
          "type": "single_choice",
          "question": "B+木インデックスで範囲検索が効率的に行える理由として正しいものはどれか。",
          "choices": [
            { "value": "a", "text": "リーフノードが順序付き連結リストになっているため" },
            { "value": "b", "text": "各ノードがハッシュ値で管理されているため" },
            { "value": "c", "text": "インデックスがページキャッシュに常駐するため" },
            { "value": "d", "text": "ノード分割時に全データが再配置されるため" }
          ],
          "correct": "a",
          "explanation": "B+木はリーフノード同士が連結されており、範囲検索ではリーフを順次辿るだけで済むため高速である。"
        },
        {
          "type": "single_choice",
          "question": "実行計画でハッシュ結合よりネストループ結合が選択されやすい状況として最も適切なものはどれか。",
          "choices": [
            { "value": "a", "text": "外側テーブルが小さく内側テーブルにインデックスがある" },
            { "value": "b", "text": "両テーブルが巨大でインデックスがない" },
            { "value": "c", "text": "結合条件が OR 演算のみである" },
            { "value": "d", "text": "統計情報が存在しない" }
          ],
          "correct": "a",
          "explanation": "ネストループは外側が小さく内側に索引が効く場合、ランダム I/O が少なく最速となる可能性が高い。"
        },
        {
          "type": "single_choice",
          "question": "列指向ストレージエンジンが行指向より優れる典型的なワークロードはどれか。",
          "choices": [
            { "value": "a", "text": "OLTP の頻繁な INSERT/UPDATE" },
            { "value": "b", "text": "大規模データの集計・分析クエリ" },
            { "value": "c", "text": "テキスト全文検索" },
            { "value": "d", "text": "ランダムに 1 行取得するプライマリキー検索" }
          ],
          "correct": "b",
          "explanation": "列指向は必要列のみを連続で読み込めるため、広いテーブルへの集計系読み取りが特に高速化する。"
        },
        {
          "type": "multiple_choice",
          "question": "インデックススキャンではなくシーケンシャルスキャンを RDBMS が選択する要因として適切なものをすべて選べ。",
          "choices": [
            { "value": "a", "text": "対象行が全体の高割合を占める" },
            { "value": "b", "text": "統計情報が古く誤差が大きい" },
            { "value": "c", "text": "テーブルが非常に小さい" },
            { "value": "d", "text": "インデックスがクラスタ化されている" },
            { "value": "e", "text": "WHERE 句がインデックス列で前方一致しない" }
          ],
          "correct": ["a", "b", "c", "e"],
          "explanation": "高選択率・小テーブル・統計不整合・索引不適合の条件ではフルスキャンの方がコストが低いと判断される。"
        },
        {
          "type": "essay",
          "question": "レンジパーティショニングとハッシュパーティショニングの特徴を比較し、運用面での選択指針を300字以内で説明せよ。",
          "correct": "",
          "explanation": "レンジは時系列データで管理容易、ハッシュは均一分散でホットスポット回避など、利点と欠点を比較させる。"
        }
      ]
    },
    {
      "id": "security",
      "title": "セキュリティ",
      "questions": [
        {
          "type": "single_choice",
          "question": "SQL インジェクション対策として推奨されるプリペアドステートメントの特徴はどれか。",
          "choices": [
            { "value": "a", "text": "SQL 文字列を動的連結して実行" },
            { "value": "b", "text": "パラメータを事前コンパイルし型検査する" },
            { "value": "c", "text": "入力を HTML エスケープする" },
            { "value": "d", "text": "データベース側で権限昇格を行う" }
          ],
          "correct": "b",
          "explanation": "プリペアドステートメントは構文解析済みの SQL にパラメータをバインドし、文字列連結を排除することで注入を防止する。"
        },
        {
          "type": "single_choice",
          "question": "透過的データ暗号化 (TDE) を導入する主目的として適切なものはどれか。",
          "choices": [
            { "value": "a", "text": "SQL 実行速度を向上" },
            { "value": "b", "text": "ディスク盗難時のデータ漏えい防止" },
            { "value": "c", "text": "ユーザパスワード簡略化" },
            { "value": "d", "text": "メモリ使用量削減" }
          ],
          "correct": "b",
          "explanation": "TDE はストレージ上のデータを暗号化し、ディスクやバックアップ媒体流出時に平文漏えいを防ぐ。"
        },
        {
          "type": "single_choice",
          "question": "データベース監査ログ設計において「不可否認性」を高める施策として最も適切なのはどれか。",
          "choices": [
            { "value": "a", "text": "ログファイルを gzip 圧縮" },
            { "value": "b", "text": "ハッシュチェーンや署名で改ざん検知" },
            { "value": "c", "text": "ログを 1 週間ごとに削除" },
            { "value": "d", "text": "アクセス数をサンプリングして記録" }
          ],
          "correct": "b",
          "explanation": "ログ改ざんを検知・防止するハッシュチェーンや電子署名は不可否認性の確保に不可欠。"
        },
        {
          "type": "multiple_choice",
          "question": "ロールベースアクセス制御 (RBAC) の利点として正しいものをすべて選べ。",
          "choices": [
            { "value": "a", "text": "最小権限の実現を容易にする" },
            { "value": "b", "text": "個別ユーザへ直接権限付与が不要" },
            { "value": "c", "text": "動的属性による細粒度制御が容易" },
            { "value": "d", "text": "人員変更時の権限管理が簡素" },
            { "value": "e", "text": "コンテキスト依存制御が標準で可能" }
          ],
          "correct": ["a", "b", "d"],
          "explanation": "RBAC はロールを介して権限を集約し、最小権限を保ちつつユーザ管理を簡素化できる。属性依存制御は ABAC の範囲。"
        },
        {
          "type": "essay",
          "question": "データベースの列レベル暗号化と透過的データ暗号化 (TDE) の違いを比較し、選択時の判断基準を説明せよ (300 字以内)。",
          "correct": "",
          "explanation": "列暗号はきめ細かい制御が可能だがアプリ修正が必要、TDE は運用容易だが列単位制御は不可などの比較を論述させる。"
        },
        {
          "type": "single_choice",
          "question": "プリペアドステートメントが SQL インジェクション対策として有効な理由はどれか。",
          "choices": [
            { "value": "a", "text": "SQL の構文解析をパラメータバインド前に済ませるため" },
            { "value": "b", "text": "入力値を自動で HTML エスケープするため" },
            { "value": "c", "text": "DB セッションを暗号化するため" },
            { "value": "d", "text": "実行計画をキャッシュしないため" }
          ],
          "correct": "a",
          "explanation": "プリペアドは SQL を事前コンパイルし、ユーザ入力は単なるパラメータとして扱うため、構文改変が不可能になる。"
        },
        {
          "type": "single_choice",
          "question": "透過的データ暗号化 (TDE) の主な導入目的として正しいものはどれか。",
          "choices": [
            { "value": "a", "text": "ディスク盗難時のデータ漏えい防止" },
            { "value": "b", "text": "ユーザ認証の高速化" },
            { "value": "c", "text": "SQL 文の実行速度向上" },
            { "value": "d", "text": "全文検索機能の向上" }
          ],
          "correct": "a",
          "explanation": "TDE はストレージ上のデータを暗号化し、ディスクやバックアップ媒体が流出しても平文を守ることが目的である。"
        },
        {
          "type": "single_choice",
          "question": "監査ログの不可否認性を高める方法として最も適切なものはどれか。",
          "choices": [
            { "value": "a", "text": "ログにハッシュチェーンや電子署名を付与し改ざん検知を行う" },
            { "value": "b", "text": "ログを1日ごとに削除して容量を減らす" },
            { "value": "c", "text": "ログを gzip 圧縮して保存する" },
            { "value": "d", "text": "ログ出力先を /tmp に設定する" }
          ],
          "correct": "a",
          "explanation": "ハッシュや署名でログ改ざんを検出・防止することが不可否認性確保の基本である。"
        },
        {
          "type": "multiple_choice",
          "question": "ロールベースアクセス制御 (RBAC) の利点として正しいものをすべて選べ。",
          "choices": [
            { "value": "a", "text": "最小権限原則を適用しやすい" },
            { "value": "b", "text": "人事異動時の権限変更が容易" },
            { "value": "c", "text": "ユーザに直接権限を付与するため設定がシンプル" },
            { "value": "d", "text": "ロール単位で監査が行いやすい" },
            { "value": "e", "text": "暗号鍵管理が不要になる" }
          ],
          "correct": ["a", "b", "d"],
          "explanation": "RBAC は権限をロールに集約しユーザをロールに割り当てるため、権限管理と監査が簡素化され最小権限を保ちやすい。"
        },
        {
          "type": "essay",
          "question": "列レベル暗号化と透過的データ暗号化 (TDE) の相違点と選択基準について300字以内で説明せよ。",
          "correct": "",
          "explanation": "列暗号は細粒度制御が可能だがアプリ改修が必要、TDE は導入が容易だが列単位制御不可など、使い分けの観点を論述させる。"
        }
      ]
    },
    {
      "id": "transaction",
      "title": "トランザクション・同期処理",
      "questions": [
        {
          "type": "single_choice",
          "question": "ACID 特性のうち『一貫性 (Consistency)』が保証するものとして正しい説明はどれか。",
          "choices": [
            { "value": "a", "text": "同時実行時に結果が直列化可能" },
            { "value": "b", "text": "トランザクション完了時に整合制約が満たされる" },
            { "value": "c", "text": "障害時にロールバック可能" },
            { "value": "d", "text": "部分コミットが許可される" }
          ],
          "correct": "b",
          "explanation": "一貫性はトランザクション前後で DB が定義された整合制約を常に満たすことを意味する。"
        },
        {
          "type": "single_choice",
          "question": "行レベルロックで共有ロック (S ロック) を保持しているトランザクションが行える操作はどれか。",
          "choices": [
            { "value": "a", "text": "行の SELECT" },
            { "value": "b", "text": "行の UPDATE" },
            { "value": "c", "text": "行の DELETE" },
            { "value": "d", "text": "行の ALTER" }
          ],
          "correct": "a",
          "explanation": "共有ロックは読み取り専用アクセスを許可し、書き込み操作を排他する。"
        },
        {
          "type": "single_choice",
          "question": "デッドロックが発生した場合、ほとんどの RDBMS が採用する解決策はどれか。",
          "choices": [
            { "value": "a", "text": "待ち続けてユーザ介入を待つ" },
            { "value": "b", "text": "最長待機トランザクションを強制ロールバック" },
            { "value": "c", "text": "全トランザクションをロールバック" },
            { "value": "d", "text": "ロック昇格を自動実行" }
          ],
          "correct": "b",
          "explanation": "多くの DB ではデッドロック検出後、犠牲者選択アルゴリズムで特定トランザクションをロールバックする。"
        },
        {
          "type": "multiple_choice",
          "question": "トランザクション分離レベル READ COMMITTED で発生し得る現象をすべて選べ。",
          "choices": [
            { "value": "a", "text": "ダーティリード" },
            { "value": "b", "text": "ノンリピータブルリード" },
            { "value": "c", "text": "ファントムリード" },
            { "value": "d", "text": "ロストアップデート" },
            { "value": "e", "text": "シリアライザブルアノマリ" }
          ],
          "correct": ["b", "c", "d"],
          "explanation": "RC ではコミット済みデータのみ読めるためダーティリードは防止されるが、NRR・ファントム・ロストアップデートは起こり得る。"
        },
        {
          "type": "essay",
          "question": "分散トランザクションで 2PC (二相コミット) が採用される理由と、その欠点をフォールトトレラント設計の観点で論じよ (300 字以内)。",
          "correct": "",
          "explanation": "2PC は原子性を保証するがコーディネータ障害時にブロッキング、遅延などが問題となるため解説させる。"
        },
        {
          "type": "single_choice",
          "question": "ACID 特性の一つである一貫性 (Consistency) が保証する内容として最も適切なものはどれか。",
          "choices": [
            { "value": "a", "text": "トランザクション開始前に設定された整合制約が完了後も満たされる" },
            { "value": "b", "text": "同時実行時に結果が直列化可能になる" },
            { "value": "c", "text": "システム障害時にロールバック可能になる" },
            { "value": "d", "text": "複数データベース間で即時同期が行われる" }
          ],
          "correct": "a",
          "explanation": "一貫性はトランザクションの実行前後でデータベースが定義された整合制約を常に満たすことを保証する。"
        },
        {
          "type": "single_choice",
          "question": "共有ロック (Sロック) を取得した行に対して他トランザクションが行える操作として正しいものはどれか。",
          "choices": [
            { "value": "a", "text": "同じ行の SELECT" },
            { "value": "b", "text": "同じ行の UPDATE" },
            { "value": "c", "text": "同じ行の DELETE" },
            { "value": "d", "text": "同じ行への排他ロック獲得" }
          ],
          "correct": "a",
          "explanation": "共有ロックは読取り専用アクセスを許可し書込みを排他するため、SELECT のみが許容される。"
        },
        {
          "type": "single_choice",
          "question": "一般的な RDBMS がデッドロックを解消する際に用いる方法として最も適切なものはどれか。",
          "choices": [
            { "value": "a", "text": "循環待ちを検出し一方のトランザクションをロールバックする" },
            { "value": "b", "text": "全トランザクションを一斉ロールバックする" },
            { "value": "c", "text": "ユーザ介入を待って処理を継続する" },
            { "value": "d", "text": "ロック昇格を強制的に行う" }
          ],
          "correct": "a",
          "explanation": "犠牲者選択アルゴリズムで循環待ちの一方をロールバックし、残りを継続させるのが一般的である。"
        },
        {
          "type": "multiple_choice",
          "question": "トランザクション分離レベル READ COMMITTED で発生し得る現象をすべて選べ。",
          "choices": [
            { "value": "a", "text": "ダーティリード" },
            { "value": "b", "text": "ノンリピータブルリード" },
            { "value": "c", "text": "ファントムリード" },
            { "value": "d", "text": "ロストアップデート" },
            { "value": "e", "text": "シリアライザブルアノマリ" }
          ],
          "correct": ["b", "c", "d"],
          "explanation": "READ COMMITTED はコミット済みのみ読めるためダーティリードは防止されるが、NRR・ファントム・ロストアップデートは防げない。"
        },
        {
          "type": "essay",
          "question": "分散トランザクションで二相コミット (2PC) が採用される理由と、その欠点をフォールトトレラント設計の観点から300字以内で論じよ。",
          "correct": "",
          "explanation": "2PC は原子性を保証するがコーディネータ障害時のブロッキングや遅延などが欠点であり、フォールトトレランスには補完策が必要となる。"
        }
      ]
    }
  ]
}
