{
  "sections": [
    {
      "id": "database-design",
      "title": "データベース設計",
      "questions": [
        {
          "id": "q1-1",
          "number": "問題 1-1",
          "type": "single_choice",
          "question": "E-R 図で「1 対多」の多側を表す適切な表記は次のうちどれか。",
          "choices": [
            { "value": "a", "text": "菱形を多側エンティティに付加" },
            { "value": "b", "text": "クロウズフットを多側に描く" },
            { "value": "c", "text": "二重線を多側に描く" },
            { "value": "d", "text": "矢印を多側に向ける" }
          ],
          "correct": "b",
          "explanation": "クロウズフット記法では多側（0..*, 1..* など）に三又の足形を描くことで多重度を示す。"
        },
        {
          "id": "q1-2",
          "number": "問題 1-2",
          "type": "single_choice",
          "question": "物理設計でパーティションキーを選定する主な目的として最も適切なものはどれか。",
          "choices": [
            { "value": "a", "text": "スキーマの可読性向上" },
            { "value": "b", "text": "論理削除の簡素化" },
            { "value": "c", "text": "I/O 並列性と局所性の最適化" },
            { "value": "d", "text": "SQL 文の短縮" }
          ],
          "correct": "c",
          "explanation": "パーティションキーはデータ配置を物理的に分割し、I/O 並列性とキャッシュ局所性を高めるために選定する。"
        },
        {
          "id": "q1-3",
          "number": "問題 1-3",
          "type": "single_choice",
          "question": "外部キー制約を論理設計段階で定義しておく主な利点はどれか。",
          "choices": [
            { "value": "a", "text": "統合テストのコスト削減" },
            { "value": "b", "text": "参照整合性をスキーマで強制できる" },
            { "value": "c", "text": "SQL 文の自動生成が容易" },
            { "value": "d", "text": "アプリケーション側ロジック削減が困難" }
          ],
          "correct": "b",
          "explanation": "外部キー制約は RDBMS が参照整合性を保証するため、設計段階で定義することで不整合データの混入を防止できる。"
        },
        {
          "id": "q1-4",
          "number": "問題 1-4",
          "type": "multiple_choice",
          "question": "概念設計においてエンティティを抽出する際の代表的な手法として適切なものをすべて選べ。",
          "choices": [
            { "value": "a", "text": "名詞抽出法" },
            { "value": "b", "text": "時系列分析法" },
            { "value": "c", "text": "CRUD 行列法" },
            { "value": "d", "text": "トリガベース分析法" },
            { "value": "e", "text": "ダミーデータ生成法" }
          ],
          "correct": ["a", "c"],
          "explanation": "名詞抽出法と CRUD 行列法は実務で広く用いられる。時系列分析はイベント抽出、トリガは運用設計寄りでエンティティ抽出手法とは異なる。"
        },
        {
          "id": "q1-5",
          "number": "問題 1-5",
          "type": "essay",
          "question": "概念設計と論理設計の違いを 300 字以内で説明し、両者の成果物が後続工程に与える影響について述べよ。",
          "correct": "",
          "explanation": "概念設計は業務要件を抽象化しエンティティ・関係を明確化、論理設計は RDBMS 非依存でキーや属性を定義する工程である。後続の物理設計や SQL 実装に直接影響するため理解が重要。"
        }
      ]
    },
    {
      "id": "sql",
      "title": "SQL",
      "questions": [
        {
          "id": "q2-1",
          "number": "問題 2-1",
          "type": "single_choice",
          "question": "ウィンドウ関数 ROW_NUMBER() の主な用途として正しいものはどれか。",
          "choices": [
            { "value": "a", "text": "行をランダムに抽出する" },
            { "value": "b", "text": "パーティション内で順位を付与する" },
            { "value": "c", "text": "複数列の NULL を置換する" },
            { "value": "d", "text": "JSON をパースする" }
          ],
          "correct": "b",
          "explanation": "ROW_NUMBER() は PARTITION BY と ORDER BY で区切ったパーティション内に連番を付与するウィンドウ関数である。"
        },
        {
          "id": "q2-2",
          "number": "問題 2-2",
          "type": "single_choice",
          "question": "PostgreSQL などで JSON 列からキー \"price\" を数値として抽出する SQL 例として適切なのはどれか。",
          "choices": [
            { "value": "a", "text": "SELECT price::json FROM items;" },
            { "value": "b", "text": "SELECT items->>'price'::numeric FROM items;" },
            { "value": "c", "text": "SELECT (items->>'price')::numeric FROM items;" },
            { "value": "d", "text": "SELECT json_extract(price) FROM items;" }
          ],
          "correct": "c",
          "explanation": "->> でテキスト抽出後にキャスト ( ... )::numeric する。選択肢 b はキャスト位置が誤り。"
        },
        {
          "id": "q2-3",
          "number": "問題 2-3",
          "type": "single_choice",
          "question": "SQL92 で定義された外部結合のうち FULL OUTER JOIN の結果について正しい説明はどれか。",
          "choices": [
            { "value": "a", "text": "結合条件を満たす行のみを返す" },
            { "value": "b", "text": "左テーブルの全行と一致行を返す" },
            { "value": "c", "text": "両テーブルの全行を返し一致しない側は NULL" },
            { "value": "d", "text": "右テーブルの全行と一致行を返す" }
          ],
          "correct": "c",
          "explanation": "FULL OUTER JOIN は LEFT と RIGHT の和集合であり、どちらにも一致しない側の列は NULL を返す。"
        },
        {
          "id": "q2-4",
          "number": "問題 2-4",
          "type": "multiple_choice",
          "question": "SQL 標準で定義されるトランザクション分離レベルに含まれるものをすべて選べ。",
          "choices": [
            { "value": "a", "text": "READ UNCOMMITTED" },
            { "value": "b", "text": "READ COMMITTED" },
            { "value": "c", "text": "REPEATABLE READ" },
            { "value": "d", "text": "SERIALIZABLE" },
            { "value": "e", "text": "LINEARIZABLE" }
          ],
          "correct": ["a", "b", "c", "d"],
          "explanation": "SQL 標準は 4 段階 (RU, RC, RR, S) を規定し、LINEARIZABLE は分散 DB で用いられる概念で標準には含まれない。"
        },
        {
          "id": "q2-5",
          "number": "問題 2-5",
          "type": "essay",
          "question": "WITH 句 (共通テーブル式) を用いた再帰クエリの仕組みと実用例について 300 字以内で説明せよ。",
          "correct": "",
          "explanation": "再帰 WITH は UNION ALL と固定名 CTE を用いて階層データを走査できる。階層構造メニュー、組織ツリー集計などで有効。"
        }
      ]
    },
    {
      "id": "normalization",
      "title": "正規化・データモデリング",
      "questions": [
        {
          "id": "q3-1",
          "number": "問題 3-1",
          "type": "single_choice",
          "question": "第 3 正規形 (3NF) が満たすべき条件として正しいものはどれか。",
          "choices": [
            { "value": "a", "text": "非キー属性が候補キーに完全関数従属" },
            { "value": "b", "text": "非キー属性が他の非キー属性に推移従属" },
            { "value": "c", "text": "全ての決定因子が候補キー" },
            { "value": "d", "text": "主キーが単一列である" }
          ],
          "correct": "a",
          "explanation": "3NF は非キー属性が候補キーに完全関数従属し、かつ非キー属性間に推移従属がない状態を指す。"
        },
        {
          "id": "q3-2",
          "number": "問題 3-2",
          "type": "single_choice",
          "question": "BCNF への変換過程で起こり得る主キーの変化に関する説明として正しいものはどれか。",
          "choices": [
            { "value": "a", "text": "常に主キーが短縮される" },
            { "value": "b", "text": "主キーが複数テーブルに分割される場合がある" },
            { "value": "c", "text": "主キーは変化せずテーブル数だけ増える" },
            { "value": "d", "text": "主キーが外部キーへ自動的に変換される" }
          ],
          "correct": "b",
          "explanation": "BCNF 分解では決定因子を持つ属性群が分離されるため、元の主キーが複数テーブルに分散する場合がある。"
        },
        {
          "id": "q3-3",
          "number": "問題 3-3",
          "type": "single_choice",
          "question": "関数従属性 X→Y が成立する場合の Armstrong 公理に基づく推論として誤っているものはどれか。",
          "choices": [
            { "value": "a", "text": "推移律: X→Z かつ Z→Y なら X→Y" },
            { "value": "b", "text": "拡張律: X→Y なら XZ→YZ" },
            { "value": "c", "text": "合体律: X→Y および X→Z なら X→YZ" },
            { "value": "d", "text": "分解律: X→YZ なら X→Z は導けない" }
          ],
          "correct": "d",
          "explanation": "分解律により X→YZ なら X→Z, X→Y が導けるため「導けない」は誤り。"
        },
        {
          "id": "q3-4",
          "number": "問題 3-4",
          "type": "multiple_choice",
          "question": "次のうち、第 1 正規形 (1NF) を満たしていない状態の例として該当するものをすべて選べ。",
          "choices": [
            { "value": "a", "text": "列に可変長配列を格納" },
            { "value": "b", "text": "繰り返し属性を行で表現" },
            { "value": "c", "text": "複数値属性をカンマ区切りで格納" },
            { "value": "d", "text": "主キーに NULL 値が存在" },
            { "value": "e", "text": "列にスカラー値のみを格納" }
          ],
          "correct": ["a", "c"],
          "explanation": "1NF では列が原子的である必要があり、配列やカンマ区切りで複数値を格納するのは違反。"
        },
        {
          "id": "q3-5",
          "number": "問題 3-5",
          "type": "essay",
          "question": "データウェアハウス設計で 3NF ではなくスター・スキーマが採用される理由と利点を具体例を交えて述べよ (300 字以内)。",
          "correct": "",
          "explanation": "スター・スキーマは結合が単純で集計クエリが高速化するなど BI ツールと相性が良い。論述で詳細を評価。"
        }
      ]
    },
    {
      "id": "performance",
      "title": "性能・チューニング",
      "questions": [
        {
          "id": "q4-1",
          "number": "問題 4-1",
          "type": "single_choice",
          "question": "B+ 木インデックスにおいてリーフノードのみを順次走査する操作はどの SQL 句と最も関係が深いか。",
          "choices": [
            { "value": "a", "text": "ORDER BY" },
            { "value": "b", "text": "GROUP BY" },
            { "value": "c", "text": "HAVING" },
            { "value": "d", "text": "DISTINCT" }
          ],
          "correct": "a",
          "explanation": "B+ 木はリーフノードが順序付き連結リストになっているため ORDER BY の実装で効率的な範囲走査が可能。"
        },
        {
          "id": "q4-2",
          "number": "問題 4-2",
          "type": "single_choice",
          "question": "実行計画で Nested Loop Join が Hash Join より有利になる典型的な条件はどれか。",
          "choices": [
            { "value": "a", "text": "両テーブルとも非常に大きい" },
            { "value": "b", "text": "片方が小さくインデックスが有効" },
            { "value": "c", "text": "両テーブルが同サイズでソート済み" },
            { "value": "d", "text": "ディスクフルスキャンが必要" }
          ],
          "correct": "b",
          "explanation": "Nested Loop は外側が小さく内側にインデックスがある場合に最少 I/O で結合できる。"
        },
        {
          "id": "q4-3",
          "number": "問題 4-3",
          "type": "single_choice",
          "question": "列指向ストレージエンジンが行指向よりも優れる典型的ワークロードはどれか。",
          "choices": [
            { "value": "a", "text": "OLTP の INSERT/UPDATE" },
            { "value": "b", "text": "頻繁なトリガ実行" },
            { "value": "c", "text": "大量データの集計クエリ" },
            { "value": "d", "text": "ランダム行単独取得" }
          ],
          "correct": "c",
          "explanation": "列指向は必要列のみ連続的に読み込めるため集計・分析系 (OLAP) に特に効果を発揮する。"
        },
        {
          "id": "q4-4",
          "number": "問題 4-4",
          "type": "multiple_choice",
          "question": "次のうち、インデックススキャンを避けてシーケンシャルスキャンを選択する要因として RDBMS が考慮するものをすべて選べ。",
          "choices": [
            { "value": "a", "text": "インデックスのカーディナリティが低い" },
            { "value": "b", "text": "統計情報が古い" },
            { "value": "c", "text": "クエリがワイルドカード前方一致" },
            { "value": "d", "text": "テーブルが極端に小さい" },
            { "value": "e", "text": "ヒープ領域が圧縮されている" }
          ],
          "correct": ["a", "b", "d"],
          "explanation": "低カーディナリティや小テーブルではランダム I/O より全スキャンが速いと判断。統計情報不整合も影響。"
        },
        {
          "id": "q4-5",
          "number": "問題 4-5",
          "type": "essay",
          "question": "レンジパーティショニングとハッシュパーティショニングの特性を比較し、運用面での選択指針を 300 字以内で述べよ。",
          "correct": "",
          "explanation": "レンジは時間系列などで均等分布困難だが管理容易、ハッシュは均等分布しやすいが分割管理が複雑。"
        }
      ]
    },
    {
      "id": "security",
      "title": "セキュリティ",
      "questions": [
        {
          "id": "q5-1",
          "number": "問題 5-1",
          "type": "single_choice",
          "question": "SQL インジェクション対策として推奨されるプリペアドステートメントの特徴はどれか。",
          "choices": [
            { "value": "a", "text": "SQL 文字列を動的連結して実行" },
            { "value": "b", "text": "パラメータを事前コンパイルし型検査する" },
            { "value": "c", "text": "入力を HTML エスケープする" },
            { "value": "d", "text": "データベース側で権限昇格を行う" }
          ],
          "correct": "b",
          "explanation": "プリペアドステートメントは構文解析済みの SQL にパラメータをバインドし、文字列連結を排除することで注入を防止する。"
        },
        {
          "id": "q5-2",
          "number": "問題 5-2",
          "type": "single_choice",
          "question": "透過的データ暗号化 (TDE) を導入する主目的として適切なものはどれか。",
          "choices": [
            { "value": "a", "text": "SQL 実行速度を向上" },
            { "value": "b", "text": "ディスク盗難時のデータ漏えい防止" },
            { "value": "c", "text": "ユーザパスワード簡略化" },
            { "value": "d", "text": "メモリ使用量削減" }
          ],
          "correct": "b",
          "explanation": "TDE はストレージ上のデータを暗号化し、ディスクやバックアップ媒体流出時に平文漏えいを防ぐ。"
        },
        {
          "id": "q5-3",
          "number": "問題 5-3",
          "type": "single_choice",
          "question": "データベース監査ログ設計において「不可否認性」を高める施策として最も適切なのはどれか。",
          "choices": [
            { "value": "a", "text": "ログファイルを gzip 圧縮" },
            { "value": "b", "text": "ハッシュチェーンや署名で改ざん検知" },
            { "value": "c", "text": "ログを 1 週間ごとに削除" },
            { "value": "d", "text": "アクセス数をサンプリングして記録" }
          ],
          "correct": "b",
          "explanation": "ログ改ざんを検知・防止するハッシュチェーンや電子署名は不可否認性の確保に不可欠。"
        },
        {
          "id": "q5-4",
          "number": "問題 5-4",
          "type": "multiple_choice",
          "question": "ロールベースアクセス制御 (RBAC) の利点として正しいものをすべて選べ。",
          "choices": [
            { "value": "a", "text": "最小権限の実現を容易にする" },
            { "value": "b", "text": "個別ユーザへ直接権限付与が不要" },
            { "value": "c", "text": "動的属性による細粒度制御が容易" },
            { "value": "d", "text": "人員変更時の権限管理が簡素" },
            { "value": "e", "text": "コンテキスト依存制御が標準で可能" }
          ],
          "correct": ["a", "b", "d"],
          "explanation": "RBAC はロールを介して権限を集約し、最小権限を保ちつつユーザ管理を簡素化できる。属性依存制御は ABAC の範囲。"
        },
        {
          "id": "q5-5",
          "number": "問題 5-5",
          "type": "essay",
          "question": "データベースの列レベル暗号化と透過的データ暗号化 (TDE) の違いを比較し、選択時の判断基準を説明せよ (300 字以内)。",
          "correct": "",
          "explanation": "列暗号はきめ細かい制御が可能だがアプリ修正が必要、TDE は運用容易だが列単位制御は不可などの比較を論述させる。"
        }
      ]
    },
    {
      "id": "transaction",
      "title": "トランザクション・同期処理",
      "questions": [
        {
          "id": "q6-1",
          "number": "問題 6-1",
          "type": "single_choice",
          "question": "ACID 特性のうち『一貫性 (Consistency)』が保証するものとして正しい説明はどれか。",
          "choices": [
            { "value": "a", "text": "同時実行時に結果が直列化可能" },
            { "value": "b", "text": "トランザクション完了時に整合制約が満たされる" },
            { "value": "c", "text": "障害時にロールバック可能" },
            { "value": "d", "text": "部分コミットが許可される" }
          ],
          "correct": "b",
          "explanation": "一貫性はトランザクション前後で DB が定義された整合制約を常に満たすことを意味する。"
        },
        {
          "id": "q6-2",
          "number": "問題 6-2",
          "type": "single_choice",
          "question": "行レベルロックで共有ロック (S ロック) を保持しているトランザクションが行える操作はどれか。",
          "choices": [
            { "value": "a", "text": "行の SELECT" },
            { "value": "b", "text": "行の UPDATE" },
            { "value": "c", "text": "行の DELETE" },
            { "value": "d", "text": "行の ALTER" }
          ],
          "correct": "a",
          "explanation": "共有ロックは読み取り専用アクセスを許可し、書き込み操作を排他する。"
        },
        {
          "id": "q6-3",
          "number": "問題 6-3",
          "type": "single_choice",
          "question": "デッドロックが発生した場合、ほとんどの RDBMS が採用する解決策はどれか。",
          "choices": [
            { "value": "a", "text": "待ち続けてユーザ介入を待つ" },
            { "value": "b", "text": "最長待機トランザクションを強制ロールバック" },
            { "value": "c", "text": "全トランザクションをロールバック" },
            { "value": "d", "text": "ロック昇格を自動実行" }
          ],
          "correct": "b",
          "explanation": "多くの DB ではデッドロック検出後、犠牲者選択アルゴリズムで特定トランザクションをロールバックする。"
        },
        {
          "id": "q6-4",
          "number": "問題 6-4",
          "type": "multiple_choice",
          "question": "トランザクション分離レベル READ COMMITTED で発生し得る現象をすべて選べ。",
          "choices": [
            { "value": "a", "text": "ダーティリード" },
            { "value": "b", "text": "ノンリピータブルリード" },
            { "value": "c", "text": "ファントムリード" },
            { "value": "d", "text": "ロストアップデート" },
            { "value": "e", "text": "シリアライザブルアノマリ" }
          ],
          "correct": ["b", "c", "d"],
          "explanation": "RC ではコミット済みデータのみ読めるためダーティリードは防止されるが、NRR・ファントム・ロストアップデートは起こり得る。"
        },
        {
          "id": "q6-5",
          "number": "問題 6-5",
          "type": "essay",
          "question": "分散トランザクションで 2PC (二相コミット) が採用される理由と、その欠点をフォールトトレラント設計の観点で論じよ (300 字以内)。",
          "correct": "",
          "explanation": "2PC は原子性を保証するがコーディネータ障害時にブロッキング、遅延などが問題となるため解説させる。"
        }
      ]
    }
  ]
}
